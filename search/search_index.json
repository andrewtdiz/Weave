{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#roblox-made-simple","title":"Roblox made simple.","text":"<p> Weave is a library for insanely fast development in Roblox.  </p> <p> Define state and how the data should flow, then let Weave do the rest.  </p> <p> So simple, you can set it and forget it. </p> Get started Download Weave"},{"location":"api-reference/","title":"API Reference","text":"<p>Welcome to the API Reference! This is where you can find more technical documentation about what the Weave library provides.</p> <p>This isn't a beginner's guide. For a guided experience, try the tutorials!</p>"},{"location":"api-reference/#navigation","title":"Navigation","text":"<p>Using the sidebar on the left, you can find API members grouped by category. Alternatively, you can search for APIs using the search box at the top of the page.</p>"},{"location":"api-reference/#commonly-used","title":"Commonly Used","text":""},{"location":"api-reference/#general","title":"General","text":"<p> Errors </p> <p> State </p> <p> Instances </p> <p> Animation </p>"},{"location":"api-reference/#state","title":"State","text":"<p> Computed </p> <p> ForKeys </p> <p> ForPairs </p> <p> ForValues </p> <p> Observer </p> <p> Value </p>"},{"location":"api-reference/#instances","title":"Instances","text":"<p> Hydrate </p> <p> New </p>"},{"location":"api-reference/#animation","title":"Animation","text":"<p> Spring </p> <p> Tween </p>"},{"location":"api-reference/animation/","title":"Index","text":"Weave"},{"location":"api-reference/animation/#animation","title":"Animation","text":"<p>Utilities for adding transitions and animations to state objects.</p>"},{"location":"api-reference/animation/#types","title":"Types","text":"<p> Animatable </p>"},{"location":"api-reference/animation/#state-objects","title":"State Objects","text":"<p> Spring </p> <p> Tween </p>"},{"location":"api-reference/animation/animatable/","title":"Animatable","text":"Weave Animation"},{"location":"api-reference/animation/animatable/#animatable-type-since-v01","title":"Animatable  type since v0.1","text":"<p>Represents types that can be animated component-wise. If a data type can reasonably be represented as a fixed-length array of numbers, then it is animatable.</p> <p>Any data type present in this type can be animated by Weave.</p> <pre><code>number | CFrame | Color3 | ColorSequenceKeypoint | DateTime | NumberRange |\nNumberSequenceKeypoint | PhysicalProperties | Ray | Rect | Region3 |\nRegion3int16 | UDim | UDim2 | Vector2 | Vector2int16 | Vector3 | Vector3int16\n</code></pre>"},{"location":"api-reference/animation/animatable/#example-usage","title":"Example Usage","text":"<pre><code>local DEFAULT_TWEEN = TweenInfo.new(0.25, Enum.EasingStyle.Quint)\n\nlocal function withDefaultTween(target: StateObject&lt;Animatable&gt;)\n    return Tween(target, DEFAULT_TWEEN)\nend\n</code></pre>"},{"location":"api-reference/animation/animatable/#animatability","title":"Animatability","text":"<p>Tween and Spring work by animating the individual components of whatever data they're working with. For example, if you tween a Vector3, the X, Y and Z components will have the tween individually applied to each.</p> <p>This is a very flexible definition of animatability, but it does not cover all data types. For example, it still doesn't make sense to animate a string, a boolean, or nil.</p> <p>By default, Tween and Spring will just snap to the goal value if you try to smoothly animate something that is not animatable. However, if you want to try and prevent the use of non-animatable types statically, you can use this type definition in your own code.</p>"},{"location":"api-reference/animation/spring/","title":"Spring","text":"Weave Animation"},{"location":"api-reference/animation/spring/#spring-state-object-since-v01","title":"Spring  state object since v0.1","text":"<p>Follows the value of another state object, as if linked by a damped spring.</p> <p>If the state object is not animatable, the spring will just snap to the goal value.</p> <pre><code>(\n    goal: StateObject&lt;T&gt;,\n    speed: CanBeState&lt;number&gt;?,\n    damping: CanBeState&lt;number&gt;?\n) -&gt; Spring&lt;T&gt;\n</code></pre>"},{"location":"api-reference/animation/spring/#parameters","title":"Parameters","text":"<ul> <li><code>goal</code> - The state object whose value should be followed.</li> <li><code>speed</code> - Scales the time it takes for the spring to move (but does not   directly correlate to a duration). Defaults to <code>10</code>.</li> <li><code>damping</code> - Affects the friction/damping which the spring experiences. <code>0</code>   represents no friction, and <code>1</code> is just enough friction to reach the goal   without overshooting or oscillating. Defaults to <code>1</code>.</li> </ul>"},{"location":"api-reference/animation/spring/#methods","title":"Methods","text":"<p> since v0.1 </p>"},{"location":"api-reference/animation/spring/#springget","title":"Spring:get()","text":"<p>Returns the current value stored in the state object.</p> <p>If dependencies are being captured (e.g. inside a computed callback), this state object will also be added as a dependency.</p> <pre><code>(asDependency: boolean?) -&gt; T\n</code></pre>"},{"location":"api-reference/animation/spring/#parameters_1","title":"Parameters","text":"<ul> <li><code>asDependency</code> - If this is explicitly set to false, no dependencies will be   captured.</li> </ul> <p> since v0.2 </p>"},{"location":"api-reference/animation/spring/#springsetposition","title":"Spring:setPosition()","text":"<p>Instantaneously moves the spring to a new position. This does not affect the velocity of the spring.</p> <p>If the given value doesn't have the same type as the spring's current value, the position will snap instantly to the new value.</p> <pre><code>(newPosition: T) -&gt; ()\n</code></pre>"},{"location":"api-reference/animation/spring/#parameters_2","title":"Parameters","text":"<ul> <li><code>newPosition</code> - The value the spring's position should jump to.</li> </ul> <p> since v0.2 </p>"},{"location":"api-reference/animation/spring/#springsetvelocity","title":"Spring:setVelocity()","text":"<p>Overwrites the velocity of this spring. This does not have an immediate effect on the position of the spring.</p> <p>If the given value doesn't have the same type as the spring's current value, the velocity will snap instantly to the new value.</p> <pre><code>(newVelocity: T) -&gt; ()\n</code></pre>"},{"location":"api-reference/animation/spring/#parameters_3","title":"Parameters","text":"<ul> <li><code>newVelocity</code> - The value the spring's velocity should jump to.</li> </ul> <p> since v0.2 </p>"},{"location":"api-reference/animation/spring/#springaddvelocity","title":"Spring:addVelocity()","text":"<p>Adds to the velocity of this spring. This does not have an immediate effect on the position of the spring.</p> <p>If the given value doesn't have the same type as the spring's current value, the velocity will snap instantly to the new value.</p> <pre><code>(deltaVelocity: T) -&gt; ()\n</code></pre>"},{"location":"api-reference/animation/spring/#parameters_4","title":"Parameters","text":"<ul> <li><code>deltaVelocity</code> - The velocity to add to the spring.</li> </ul>"},{"location":"api-reference/animation/spring/#example-usage","title":"Example Usage","text":"<pre><code>local position = Value(UDim2.fromOffset(25, 50))\nlocal smoothPosition = Spring(position, 25, 0.6)\n\nlocal ui = New \"Frame\" {\n    Parent = PlayerGui.ScreenGui,\n    Position = smoothPosition\n}\n\nwhile true do\n    task.wait(5)\n    -- apply an impulse\n    smoothPosition:addVelocity(UDim2.fromOffset(-10, 10))\nend\n</code></pre>"},{"location":"api-reference/animation/tween/","title":"Tween","text":"Weave Animation"},{"location":"api-reference/animation/tween/#tween-state-object-since-v01","title":"Tween  state object since v0.1","text":"<p>Follows the value of another state object, by tweening towards it.</p> <p>If the state object is not animatable, the tween will just snap to the goal value.</p> <pre><code>(\n    goal: StateObject&lt;T&gt;,\n    tweenInfo: CanBeState&lt;TweenInfo&gt;?\n) -&gt; Tween&lt;T&gt;\n</code></pre>"},{"location":"api-reference/animation/tween/#parameters","title":"Parameters","text":"<ul> <li><code>goal</code> - The state object whose value should be followed.</li> <li><code>tweenInfo</code> - The style of tween to use when moving to the goal. Defaults   to <code>TweenInfo.new()</code>.</li> </ul>"},{"location":"api-reference/animation/tween/#methods","title":"Methods","text":"<p> since v0.1 </p>"},{"location":"api-reference/animation/tween/#tweenget","title":"Tween:get()","text":"<p>Returns the current value stored in the state object.</p> <p>If dependencies are being captured (e.g. inside a computed callback), this state object will also be added as a dependency.</p> <pre><code>(asDependency: boolean?) -&gt; T\n</code></pre>"},{"location":"api-reference/animation/tween/#parameters_1","title":"Parameters","text":"<ul> <li><code>asDependency</code> - If this is explicitly set to false, no dependencies will be   captured.</li> </ul>"},{"location":"api-reference/animation/tween/#example-usage","title":"Example Usage","text":"<pre><code>local position = Value(UDim2.fromOffset(25, 50))\nlocal smoothPosition = Spring(position, 25, 0.6)\n\nlocal ui = New \"Frame\" {\n    Parent = PlayerGui.ScreenGui,\n    Position = smoothPosition\n}\n\nwhile true do\n    task.wait(5)\n    -- apply an impulse\n    smoothPosition:addVelocity(UDim2.fromOffset(-10, 10))\nend\n</code></pre>"},{"location":"api-reference/errors/","title":"Index","text":"Weave"},{"location":"api-reference/errors/#errors","title":"Errors","text":"<p>Whenever Weave outputs any errors or messages to the console, it will have a short error ID at the end. This is used to uniquely identify what kind of error or message you're seeing.</p> <p>Use the search box below to paste in or type an error ID, and it will scroll to the details for you.</p> <p></p> <p> since v0.1 </p> <p> since v0.1 </p> <p> since v0.1 </p> <p> since v0.1 </p> <p> since v0.1 </p> <p> since v0.2 </p> <p> since v0.2 </p> <p> since v0.2 </p> <p> since v0.2 </p> <p> since v0.2 </p> <p> since v0.2 </p> <p> since v0.2 </p> <p> since v0.2 </p> <p> since v0.2 </p> <p> since v0.2 </p> <p> since v0.2 </p> <p> since v0.2 </p> <p> since v0.2 </p> <p> since v0.2 </p> <p> since v0.2 </p> <p> since v0.2 </p> <p> since v0.2 </p> <p> since v0.2 </p> <p> since v0.1 </p> <p> since v0.1 </p> <p> since v0.1 </p> <p> since v0.1 </p> <p> since v0.1 </p> <p> since v0.2 </p> <p> since v0.2 </p> <p> since v0.1 </p> <p> since v0.1 </p> <p> since v0.1 </p> <p> since v0.1 </p> <p> since v0.2 </p>"},{"location":"api-reference/errors/#cannotassignproperty","title":"cannotAssignProperty","text":"<pre><code>The class type 'Foo' has no assignable property 'Bar'.\n</code></pre> <p>This message means you tried to set a property on an instance, but the property can't be assigned to. This could be because the property doesn't exist, or because it's locked by Roblox to prevent edits.</p> <p>This usually occurs with the New or Hydrate functions:</p> <pre><code>local folder = New \"Folder\" {\n    DataCost = 12345,\n    ThisPropertyDoesntExist = \"Example\"\n}\n</code></pre> <p>Tip</p> <p>Different scripts may have different privileges - for example, plugins will be allowed more privileges than in-game scripts. Make sure you have the necessary privileges to assign to your properties!</p>"},{"location":"api-reference/errors/#cannotconnectchange","title":"cannotConnectChange","text":"<pre><code>The Frame class doesn't have a property called 'Foo'.\n</code></pre> <p>This message means you tried to connect to a property change event, but the property you specify doesn't exist on the instance.</p> <p>This usually occurs with the New or Hydrate functions:</p> <pre><code>local textBox = New \"TextBox\" {\n    [OnChange \"ThisPropertyDoesntExist\"] = function()\n        ...\n    end)\n}\n</code></pre>"},{"location":"api-reference/errors/#cannotconnectevent","title":"cannotConnectEvent","text":"<pre><code>The Frame class doesn't have an event called 'Foo'.\n</code></pre> <p>This message means you tried to connect to an event on an instance, but the event you specify doesn't exist on the instance.</p> <p>This usually occurs with the New or Hydrate functions:</p> <pre><code>local button = New \"TextButton\" {\n    [OnEvent \"ThisEventDoesntExist\"] = function()\n        ...\n    end)\n}\n</code></pre>"},{"location":"api-reference/errors/#cannotcreateclass","title":"cannotCreateClass","text":"<pre><code>Can't create a new instance of class 'Foo'.\n</code></pre> <p>This message means you tried to create a new instance type, but the type of instance you specify doesn't exist in Roblox.</p> <p>This usually occurs with the New function:</p> <pre><code>local instance = New \"ThisClassTypeIsInvalid\" {\n    ...\n}\n</code></pre>"},{"location":"api-reference/errors/#computedcallbackerror","title":"computedCallbackError","text":"<pre><code>Computed callback error: attempt to index a nil value\n</code></pre> <p>This message means the callback of a computed object encountered an error.</p> <pre><code>local example = Computed(function()\n    local badMath = 2 + \"fish\"\nend)\n</code></pre>"},{"location":"api-reference/errors/#destructorneededcomputed","title":"destructorNeededComputed","text":"<pre><code>To return instances from Computeds, provide a destructor function. This will be an error soon - see discussion #183 on GitHub.\n</code></pre> <p>This message shows if you return destructible values from a computed object, without also specifying how to destroy those values using a destructor.</p> <p>Learn more by visiting this discussion on GitHub.</p> <pre><code>local badComputed = Computed(function()\n    return New \"Folder\" { ... }\nend, nil)\n</code></pre>"},{"location":"api-reference/errors/#destructorneededforkeys","title":"destructorNeededForKeys","text":"<pre><code>To return instances from ForKeys, provide a destructor function. This will be an error soon - see discussion #183 on GitHub.\n</code></pre> <p>This message shows if you return destructible values from a ForKeys object, without also specifying how to destroy those values using a destructor.</p> <p>Learn more by visiting this discussion on GitHub.</p> <pre><code>local badForKeys = ForKeys(array, function(key)\n    return New \"Folder\" { ... }\nend, nil)\n</code></pre> <p>Note</p> <p>For some time during the development of v0.2, <code>ForKeys</code> would implicitly insert a destructor for you. This behaviour still works, but it's going to be removed in an upcoming version.</p>"},{"location":"api-reference/errors/#destructorneededforpairs","title":"destructorNeededForPairs","text":"<pre><code>To return instances from ForPairs, provide a destructor function. This will be an error soon - see discussion #183 on GitHub.\n</code></pre> <p>This message shows if you return destructible values from a ForPairs object, without also specifying how to destroy those values using a destructor.</p> <p>Learn more by visiting this discussion on GitHub.</p> <pre><code>local badForPairs = ForPairs(array, function(key, value)\n    return key, New \"Folder\" { ... }\nend, nil)\n</code></pre> <p>Note</p> <p>For some time during the development of v0.2, <code>ForPairs</code> would implicitly insert a destructor for you. This behaviour still works, but it's going to be removed in an upcoming version.</p>"},{"location":"api-reference/errors/#destructorneededforvalues","title":"destructorNeededForValues","text":"<pre><code>To return instances from ForValues, provide a destructor function. This will be an error soon - see discussion #183 on GitHub.\n</code></pre> <p>This message shows if you return destructible values from a ForValues object, without also specifying how to destroy those values using a destructor.</p> <p>Learn more by visiting this discussion on GitHub.</p> <pre><code>local badForValues = ForValues(array, function(value)\n    return New \"Folder\" { ... }\nend, nil)\n</code></pre> <p>Note</p> <p>For some time during the development of v0.2, <code>ForValues</code> would implicitly insert a destructor for you. This behaviour still works, but it's going to be removed in an upcoming version.</p>"},{"location":"api-reference/errors/#forkeysdestructorerror","title":"forKeysDestructorError","text":"<pre><code>ForKeys destructor error: attempt to index a nil value\n</code></pre> <p>This message means the destructor passed to a ForKeys object encountered an error.</p> <pre><code>local function destructor(x)\n    local badMath = 2 + \"fish\"\nend\n\nlocal example = ForKeys(array, doSomething, destructor)\n</code></pre>"},{"location":"api-reference/errors/#forkeyskeycollision","title":"forKeysKeyCollision","text":"<pre><code>ForKeys should only write to output key 'Charlie' once when processing key changes, but it wrote to it twice. Previously input key: 'Alice'; New input key: 'Bob'\n</code></pre> <p>This message means you returned the same value twice for two different keys in a ForKeys object.</p> <pre><code>local data = {\n    Alice = true,\n    Bob = true\n}\nlocal example = ForKeys(data, function(key)\n    if key == \"Alice\" or key == \"Bob\" then\n        return \"Charlie\"\n    end\nend)\n</code></pre>"},{"location":"api-reference/errors/#forkeysprocessorerror","title":"forKeysProcessorError","text":"<pre><code>ForKeys callback error: attempt to index a nil value\n</code></pre> <p>This message means the callback of a ForKeys object encountered an error.</p> <pre><code>local example = ForKeys(array, function(key)\n    local badMath = 2 + \"fish\"\nend)\n</code></pre>"},{"location":"api-reference/errors/#forpairsdestructorerror","title":"forPairsDestructorError","text":"<pre><code>ForPairs destructor error: attempt to index a nil value\n</code></pre> <p>This message means the destructor passed to a ForPairs object encountered an error.</p> <pre><code>local function destructor(x, y)\n    local badMath = 2 + \"fish\"\nend\n\nlocal example = ForPairs(array, doSomething, destructor)\n</code></pre>"},{"location":"api-reference/errors/#forpairskeycollision","title":"forPairsKeyCollision","text":"<pre><code>ForPairs should only write to output key 'Charlie' once when processing key changes, but it wrote to it twice. Previously input key: 'Alice'; New input key: 'Bob'\n</code></pre> <p>This message means you returned the same value twice for two different keys in a ForPairs object.</p> <pre><code>local data = {\n    Alice = true,\n    Bob = true\n}\nlocal example = ForPairs(data, function(key, value)\n    if key == \"Alice\" or key == \"Bob\" then\n        return \"Charlie\", value\n    end\nend)\n</code></pre>"},{"location":"api-reference/errors/#forpairsprocessorerror","title":"forPairsProcessorError","text":"<pre><code>ForPairs callback error: attempt to index a nil value\n</code></pre> <p>This message means the callback of a ForPairs object encountered an error.</p> <pre><code>local example = ForPairs(array, function(key, value)\n    local badMath = 2 + \"fish\"\nend)\n</code></pre>"},{"location":"api-reference/errors/#forvaluesdestructorerror","title":"forValuesDestructorError","text":"<pre><code>ForValues destructor error: attempt to index a nil value\n</code></pre> <p>This message means the destructor passed to a ForValues object encountered an error.</p> <pre><code>local function destructor(x)\n    local badMath = 2 + \"fish\"\nend\n\nlocal example = ForValues(array, doSomething, destructor)\n</code></pre>"},{"location":"api-reference/errors/#forvaluesprocessorerror","title":"forValuesProcessorError","text":"<pre><code>ForValues callback error: attempt to index a nil value\n</code></pre> <p>This message means the callback of a ForValues object encountered an error.</p> <pre><code>local example = ForValues(array, function(value)\n    local badMath = 2 + \"fish\"\nend)\n</code></pre>"},{"location":"api-reference/errors/#invalidchangehandler","title":"invalidChangeHandler","text":"<pre><code>The change handler for the 'Text' property must be a function.\n</code></pre> <p>This message means you tried to use OnChange on an instance's property, but instead of passing a function callback, you passed something else.</p> <pre><code>local input = New \"TextBox\" {\n    [OnChange \"Text\"] = \"lemons\"\n}\n</code></pre>"},{"location":"api-reference/errors/#invalideventhandler","title":"invalidEventHandler","text":"<pre><code>The handler for the 'Activated' event must be a function.\n</code></pre> <p>This message means you tried to use OnEvent on an instance's event, but instead of passing a function callback, you passed something else.</p> <pre><code>local button = New \"TextButton\" {\n    [OnEvent \"Activated\"] = \"limes\"\n}\n</code></pre>"},{"location":"api-reference/errors/#invalidpropertytype","title":"invalidPropertyType","text":"<pre><code>'Frame.Size' expected a 'UDim2' type, but got a 'Color3' type.\n</code></pre> <p>This message means you tried to set a property on an instance, but you gave it the wrong type of value.</p> <p>This usually occurs with the New or Hydrate functions:</p> <pre><code>local ui = New \"Frame\" {\n    Size = Computed(function()\n        return Color3.new(1, 0, 0)\n    end)\n}\n</code></pre>"},{"location":"api-reference/errors/#invalidreftype","title":"invalidRefType","text":"<pre><code>Instance refs must be Value objects.\n</code></pre> <p>This message means you tried to use Ref, but you didn't also give it a value object to store the instance inside of.</p> <pre><code>local thing = New \"Part\" {\n    [Ref] = 2\n}\n</code></pre>"},{"location":"api-reference/errors/#invalidouttype","title":"invalidOutType","text":"<pre><code>[Out] properties must be given Value objects.\n</code></pre> <p>This message means you tried to use Out, but you didn't also give it a value object to store the property's value inside of.</p> <pre><code>local thing = New \"Part\" {\n    [Out \"Color\"] = true\n}\n</code></pre>"},{"location":"api-reference/errors/#invalidoutproperty","title":"invalidOutProperty","text":"<pre><code>The Part class doesn't have a property called 'Flobulator'.\n</code></pre> <p>This message means you tried to read a property of an instance using Out, but the property can't be read. This could be because the property doesn't exist, or because it's locked by Roblox to prevent reading.</p> <pre><code>local value = Value()\n\nlocal thing = New \"Part\" {\n    [Out \"Flobulator\"] = value\n}\n</code></pre>"},{"location":"api-reference/errors/#invalidspringdamping","title":"invalidSpringDamping","text":"<pre><code>The damping ratio for a spring must be &gt;= 0. (damping was -0.50)\n</code></pre> <p>This message means you gave a damping ratio to a spring object which is less than 0:</p> <pre><code>local speed = 10\nlocal damping = -12345\nlocal spring = Spring(state, speed, damping)\n</code></pre> <p>Damping ratio must always be between 0 and infinity for a spring to be physically simulatable.</p>"},{"location":"api-reference/errors/#invalidspringspeed","title":"invalidSpringSpeed","text":"<pre><code>The speed of a spring must be &gt;= 0. (speed was -2.00)\n</code></pre> <p>This message means you gave a speed to a spring object which is less than 0:</p> <pre><code>local speed = -12345\nlocal spring = Spring(state, speed)\n</code></pre> <p>Since a speed of 0 is equivalent to a spring that doesn't move, any slower speed is not simulatable or physically sensible.</p>"},{"location":"api-reference/errors/#mistypedspringdamping","title":"mistypedSpringDamping","text":"<pre><code>The damping ratio for a spring must be a number. (got a boolean)\n</code></pre> <p>This message means you gave a damping ratio to a spring object which isn't a number.</p> <pre><code>local speed = 10\nlocal damping = true\nlocal spring = Spring(state, speed, damping)\n</code></pre>"},{"location":"api-reference/errors/#mistypedspringspeed","title":"mistypedSpringSpeed","text":"<pre><code>The speed of a spring must be a number. (got a boolean)\n</code></pre> <p>This message means you gave a speed to a spring object which isn't a number.</p> <pre><code>local speed = true\nlocal spring = Spring(state, speed)\n</code></pre>"},{"location":"api-reference/errors/#mistypedtweeninfo","title":"mistypedTweenInfo","text":"<pre><code>The tween info of a tween must be a TweenInfo. (got a boolean)\n</code></pre> <p>This message shows if you try to provide a tween info to a tween which isn't a TweenInfo:</p> <pre><code>local tweenInfo = true\nlocal tween = Tween(state, tweenInfo)\n</code></pre>"},{"location":"api-reference/errors/#multireturncomputed","title":"multiReturnComputed","text":"<pre><code>Returning multiple values from Computeds is discouraged, as behaviour will change soon - see discussion #189 on GitHub.\n</code></pre> <p>This message means you returned more than one value from a computed object. There are two ways this could occur; either you're explicitly returning two values (e.g. <code>return 1, 2</code>) or you're calling a function which returns two values (e.g. <code>string.find</code>).</p> <p>A simple fix is to surround your return expression with parentheses <code>()</code>, or to save it into a variable before returning it.</p> <p>Learn more by visiting this discussion on GitHub.</p> <pre><code>local badComputed = Computed(function()\n    return 1, 2, \"foo\", true\nend, nil)\n</code></pre>"},{"location":"api-reference/errors/#springtypemismatch","title":"springTypeMismatch","text":"<pre><code>The type 'number' doesn't match the spring's type 'Color3'.\n</code></pre> <p>Some methods on spring objects require incoming values to match the types previously being used on the spring.</p> <p>This message means you passed a value to one of those methods, but it wasn't the same type as the type of the spring.</p> <pre><code>local colour = State(Color3.new(1, 0, 0))\nlocal colourSpring = Spring(colour)\n\ncolourSpring:addVelocity(Vector2.new(2, 3))\n</code></pre>"},{"location":"api-reference/errors/#strictreaderror","title":"strictReadError","text":"<pre><code>'thisDoesNotExist' is not a valid member of 'Fusion'.\n</code></pre> <p>This message means you tried to access something that doesn't exist. This specifically occurs with a few 'locked' tables in Fusion, such as the table returned by the module directly.</p> <pre><code>local Foo = Fusion.thisDoesNotExist\n</code></pre>"},{"location":"api-reference/errors/#unknownmessage","title":"unknownMessage","text":"<pre><code>Unknown error: attempt to index a nil value\n</code></pre> <p>If you see this message, it's almost certainly an internal bug, so make sure to get in contact so the issue can be fixed.</p> <p>When Fusion code attempts to log a message, warning or error, it needs to provide an ID. This ID is used to show the correct message, and serves as a simple, memorable identifier if you need to look up the message later. However, if that code provides an invalid ID, then the message will be replaced with this one.</p>"},{"location":"api-reference/errors/#unrecognisedchildtype","title":"unrecognisedChildType","text":"<pre><code>'number' type children aren't accepted as children in `New`.\n</code></pre> <p>This message means you tried to pass something to Children which isn't a valid child. This usually means that you passed something that isn't an instance, array or state object.</p> <pre><code>local instance = New \"Folder\" {\n    [Children] = {\n        1, 2, 3, 4, 5,\n\n        {true, false},\n\n        State(Enum.Material.Grass)\n    }\n}\n</code></pre> <p>Note</p> <p>Note that state objects are allowed to store <code>nil</code> to represent the absence of an instance, as an exception to these rules.</p>"},{"location":"api-reference/errors/#unrecognisedpropertykey","title":"unrecognisedPropertyKey","text":"<pre><code>'number' keys aren't accepted in the property table of `New`.\n</code></pre> <p>This message means, while using New or Hydrate, you specified something in the property table that's not a property name or special key.</p> <p>Commonly, this means you accidentally specified children directly inside of the property table, rather than using the dedicated Children special key.</p> <pre><code>local folder = New \"Folder\" {\n    [Vector3.new()] = \"Example\",\n\n    \"This\", \"Shouldn't\", \"Be\", \"Here\"\n}\n</code></pre>"},{"location":"api-reference/errors/#unrecognisedpropertystage","title":"unrecognisedPropertyStage","text":"<pre><code>'discombobulate' isn't a valid stage for a special key to be applied at.\n</code></pre> <p>Fusion provides a standard interface for defining special keys which can be used to extend the functionality of New or Hydrate.</p> <p>Within this interface, keys can select when they run using the <code>stage</code> field. If an unexpected value is passed as the stage, then this error will be thrown when attempting to use the key.</p> <pre><code>local Example = {\n    type = \"SpecialKey\",\n    kind = \"Example\",\n    stage = \"discombobulate\",\n    apply = function() ... end\n}\n\nlocal folder = New \"Folder\" {\n    [Example] = \"foo\"\n}\n</code></pre>"},{"location":"api-reference/instances/","title":"Index","text":"Weave"},{"location":"api-reference/instances/#instances","title":"Instances","text":"<p>Utilities for connecting state objects to instances via code.</p>"},{"location":"api-reference/instances/#types","title":"Types","text":"<p> Child </p> <p> Component </p> <p> SpecialKey </p>"},{"location":"api-reference/instances/#functions","title":"Functions","text":"<p> Hydrate </p> <p> New </p> <p> OnChange </p> <p> OnEvent </p> <p> Out </p>"},{"location":"api-reference/instances/#special-keys","title":"Special Keys","text":"<p> Children </p> <p> Cleanup </p> <p> Ref </p>"},{"location":"api-reference/instances/child/","title":"Child","text":"Weave Instances"},{"location":"api-reference/instances/child/#child-type-since-v02","title":"Child  type since v0.2","text":"<p>Represents some UI which can be parented to an ancestor, usually via Children. The most simple kind of child is a single instance, though arrays can be used to parent multiple instances at once and state objects can be used to make the children dynamic.</p> <pre><code>Instance | {[any]: Child} | StateObject&lt;Child&gt;\n</code></pre>"},{"location":"api-reference/instances/child/#example-usage","title":"Example Usage","text":"<pre><code>-- all of the following fit the definition of Child\n\nlocal child1: Child = New \"Folder\" {}\nlocal child2: Child = {\n    New \"Folder\" {},\n    New \"Folder\" {},\n    New \"Folder\" {}\n}\nlocal child3: Child = Computed(function()\n    return New \"Folder\" {}\nend)\nlocal child4: Child = {\n    Computed(function()\n        return New \"Folder\" {}\n    end),\n    {New \"Folder\" {}, New \"Folder\" {}}\n}\n</code></pre>"},{"location":"api-reference/instances/children/","title":"Children","text":"Weave Instances"},{"location":"api-reference/instances/children/#children-special-key-since-v01","title":"Children  special key since v0.1","text":"<p>Allows parenting children to an instance, both statically and dynamically.</p>"},{"location":"api-reference/instances/children/#example-usage","title":"Example Usage","text":"<pre><code>local example = New \"Folder\" {\n    [Children] = New \"StringValue\" {\n        Value = \"I'm parented to the Folder!\"\n    }\n}\n</code></pre>"},{"location":"api-reference/instances/children/#processing-children","title":"Processing Children","text":"<p>A 'child' is defined (recursively) as:</p> <ul> <li>an instance</li> <li>a state object containing children</li> <li>an array of children</li> </ul> <p>Since this definition is recursive, arrays and state objects can be nested; that is, the following code is valid:</p> <pre><code>local example = New \"Folder\" {\n    [Children] = {\n        {\n            {\n                New \"StringValue\" {\n                    Value = \"I'm parented to the Folder!\"\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>This behaviour is especially useful when working with components - the following component can return multiple instances to be parented without disrupting the code next to it:</p> <pre><code>local function Component(props)\n    return {\n        New \"TextLabel\" {\n            LayoutOrder = 1,\n            Text = \"Instance one\"\n        },\n\n        New \"TextLabel\" {\n            LayoutOrder = 2,\n            Text = \"Instance two\"\n        }\n    }\nend\n\nlocal parent = New \"Frame\" {\n    Children = {\n        New \"UIListLayout\" {\n            SortOrder = \"LayoutOrder\"\n        },\n\n        Component {}\n    }\n}\n</code></pre> <p>When using a state object as a child, <code>Children</code> will interpret the stored value as children and watch for changes. When the value of the state object changes, it'll unparent the old children and parent the new children.</p> <p>Note</p> <p>As with bound properties, updates are deferred to the next render step, and so parenting won't occur right away.</p> <pre><code>local child1 = New \"Folder\" {\n    Name = \"Child one\"\n}\nlocal child2 = New \"Folder\" {\n    Name = \"Child two\"\n}\n\nlocal childState = State(child1)\n\nlocal parent = New \"Folder\" {\n    [Children] = childState\n}\n\nprint(parent:GetChildren()) -- { Child one }\n\nchildState:set(child2)\nwait(1) -- wait for deferred updates to run\n\nprint(parent:GetChildren()) -- { Child two }\n</code></pre> <p>Warning</p> <p>When using state objects, note that old children won't be destroyed, only unparented - it's up to you to decide if/when children need to be destroyed.</p> <pre><code>If you're using a helper like [ForValues](../../state/forvalues), instance\ncleanup is handled for you by default (though this is configurable).\n</code></pre>"},{"location":"api-reference/instances/children/#technical-details","title":"Technical Details","text":"<p>This special key runs at the <code>descendants</code> stage.</p> <p>On cleanup, all children are unparented, as if wrapped in a state object that has changed to nil.</p>"},{"location":"api-reference/instances/cleanup/","title":"Cleanup","text":"Weave Instances"},{"location":"api-reference/instances/cleanup/#cleanup-special-key-since-v02","title":"Cleanup  special key since v0.2","text":"<p>Cleans up all items given to it when the instance is destroyed, equivalent to passing the items to <code>Fusion.cleanup</code>.</p>"},{"location":"api-reference/instances/cleanup/#example-usage","title":"Example Usage","text":"<pre><code>local example1 = New \"Folder\" {\n    [Cleanup] = function()\n        print(\"I'm in danger!\")\n    end\n}\n\nlocal example2 = New \"Folder\" {\n    [Cleanup] = example1\n}\n\nlocal example3 = New \"Folder\" {\n    [Cleanup] = {\n        RunService.RenderStepped:Connect(print),\n        function()\n            print(\"I'm in danger also!\")\n        end,\n        example2\n    }\n}\n\nexample3:Destroy()\n</code></pre>"},{"location":"api-reference/instances/cleanup/#technical-details","title":"Technical Details","text":"<p>This special key runs at the <code>observer</code> stage.</p>"},{"location":"api-reference/instances/component/","title":"Component","text":"Weave Instances"},{"location":"api-reference/instances/component/#component-type-since-v02","title":"Component  type since v0.2","text":"<p>The standard type signature for UI components. They accept a property table and return a child type.</p> <pre><code>(props: {[any]: any}) -&gt; Child\n</code></pre>"},{"location":"api-reference/instances/component/#example-usage","title":"Example Usage","text":"<pre><code>-- create a Button component\nlocal function Button(props)\n    return New \"TextButton\" {\n        Text = props.Text\n    }\nend\n\n-- the Button component is compatible with the Component type\nlocal myComponent: Component = Button\n</code></pre>"},{"location":"api-reference/instances/hydrate/","title":"Hydrate","text":"Weave Instances"},{"location":"api-reference/instances/hydrate/#hydrate-function-since-v02","title":"Hydrate  function since v0.2","text":"<p>Given an instance, returns a component which modifies that instance. The property table may specify properties to set on the instance, or include special keys for more advanced operations.</p> <pre><code>(target: Instance) -&gt; Component\n</code></pre>"},{"location":"api-reference/instances/hydrate/#parameters","title":"Parameters","text":"<ul> <li><code>target</code> - the instance which the component should modify</li> </ul>"},{"location":"api-reference/instances/hydrate/#returns","title":"Returns","text":"<p>A component function. When called, it populates the target instance using the property table, then returns the target instance.</p>"},{"location":"api-reference/instances/hydrate/#example-usage","title":"Example Usage","text":"<pre><code>local myButton: TextButton = Hydrate(PlayerGui.ScreenGui.TextButton) {\n    Position = UDim2.fromScale(.5, .5),\n    AnchorPoint = Vector2.new(.5, .5),\n    Size = UDim2.fromOffset(200, 50),\n\n    Text = \"Hello, world!\",\n\n    [OnEvent \"Activated\"] = function()\n        print(\"The button was clicked!\")\n    end,\n\n    [OnChange \"Name\"] = function(newName)\n        print(\"The button was renamed to:\", newName)\n    end,\n\n    [Children] = New \"UICorner\" {\n        CornerRadius = UDim.new(0, 8)\n    }\n}\n</code></pre>"},{"location":"api-reference/instances/hydrate/#property-table-processing","title":"Property Table Processing","text":"<p>The <code>props</code> table uses a mix of string and special keys to specify attributes of the instance which should be set.</p> <p>String keys are treated as property declarations - values passed in will be set upon the instance:</p> <pre><code>local example = Hydrate(workspace.Part) {\n    -- sets the Position property\n    Position = Vector3.new(1, 2, 3)\n}\n</code></pre> <p>Passing a state object to a string key will bind the property value; when the value of the object changes, the property will update to match on the next resumption step:</p> <pre><code>local myName = State(\"Bob\")\n\nlocal example = Hydrate(workspace.Part) {\n    -- initially, the Name will be set to Bob\n    Name = myName\n}\n\n-- change the state object to store \"John\"\n-- on the next resumption step, the part's Name will change to John\nmyName:set(\"John\")\n</code></pre> <p>Special keys, such as Children or OnEvent, may also be used as keys in the property table. For more information about how special keys work, see the SpecialKey page.</p>"},{"location":"api-reference/instances/new/","title":"New","text":"Weave Instances"},{"location":"api-reference/instances/new/#new-function-since-v01","title":"New  function since v0.1","text":"<p>Given a class name, returns a component which creates instances of that class. The property table may specify properties to set on the instance, or include special keys for more advanced operations.</p> <pre><code>(className: string) -&gt; Component\n</code></pre>"},{"location":"api-reference/instances/new/#parameters","title":"Parameters","text":"<ul> <li><code>className</code> - the instance class that should be created</li> </ul>"},{"location":"api-reference/instances/new/#returns","title":"Returns","text":"<p>A component function. When called, it creates a new instance of the given class, populates it using the property table, and returns it.</p>"},{"location":"api-reference/instances/new/#example-usage","title":"Example Usage","text":"<pre><code>local myButton: TextButton = New \"TextButton\" {\n    Parent = Players.LocalPlayer.PlayerGui,\n\n    Position = UDim2.fromScale(.5, .5),\n    AnchorPoint = Vector2.new(.5, .5),\n    Size = UDim2.fromOffset(200, 50),\n\n    Text = \"Hello, world!\",\n\n    [OnEvent \"Activated\"] = function()\n        print(\"The button was clicked!\")\n    end,\n\n    [OnChange \"Name\"] = function(newName)\n        print(\"The button was renamed to:\", newName)\n    end,\n\n    [Children] = New \"UICorner\" {\n        CornerRadius = UDim.new(0, 8)\n    }\n}\n</code></pre>"},{"location":"api-reference/instances/new/#property-table-processing","title":"Property Table Processing","text":"<p>The <code>props</code> table uses a mix of string and special keys to specify attributes of the instance which should be set.</p> <p>String keys are treated as property declarations - values passed in will be set upon the instance:</p> <pre><code>local example = New \"Part\" {\n    -- sets the Position property\n    Position = Vector3.new(1, 2, 3)\n}\n</code></pre> <p>Passing a state object to a string key will bind the property value; when the value of the object changes, the property will update to match on the next resumption step:</p> <pre><code>local myName = State(\"Bob\")\n\nlocal example = New \"Part\" {\n    -- initially, the Name will be set to Bob\n    Name = myName\n}\n\n-- change the state object to store \"John\"\n-- on the next resumption step, the part's Name will change to John\nmyName:set(\"John\")\n</code></pre> <p>Special keys, such as Children or OnEvent, may also be used as keys in the property table. For more information about how special keys work, see the SpecialKey page.</p>"},{"location":"api-reference/instances/new/#default-properties","title":"Default Properties","text":"<p>The <code>New</code> function provides its own set of 'sensible default' property values for some class types, which will be used in place of Roblox defaults. This is done to opt out of some legacy features and unhelpful defaults.</p> <p>You can see the default properties Fusion uses here.</p>"},{"location":"api-reference/instances/onchange/","title":"Onchange","text":"Weave Instances"},{"location":"api-reference/instances/onchange/#onchange-function-since-v01","title":"OnChange  function since v0.1","text":"<p>Given a property name, returns a special key which connects to that property's change events. It should be used with a handler callback, which may accept the new value of the property.</p> <pre><code>(propertyName: string) -&gt; SpecialKey\n</code></pre>"},{"location":"api-reference/instances/onchange/#parameters","title":"Parameters","text":"<ul> <li><code>propertyName</code> - The name of the property to listen for changes to.</li> </ul>"},{"location":"api-reference/instances/onchange/#returns","title":"Returns","text":"<p>A special key which runs at the <code>observer</code> stage. When applied to an instance, it connects to the property change signal on the instance for the given property. The handler is run with the property's value after every change.</p>"},{"location":"api-reference/instances/onchange/#example-usage","title":"Example Usage","text":"<pre><code>New \"TextBox\" {\n    [OnChange \"Text\"] = function(newText)\n        print(\"You typed:\", newText)\n    end\n}\n</code></pre>"},{"location":"api-reference/instances/onevent/","title":"Onevent","text":"Weave Instances"},{"location":"api-reference/instances/onevent/#onevent-function-since-v01","title":"OnEvent  function since v0.1","text":"<p>Given an event name, returns a special key which connects to events of that name. It should be used with a handler callback, which may accept arguments from the event.</p> <pre><code>(eventName: string) -&gt; SpecialKey\n</code></pre>"},{"location":"api-reference/instances/onevent/#parameters","title":"Parameters","text":"<ul> <li><code>eventName</code> - the name of the event to connect to</li> </ul>"},{"location":"api-reference/instances/onevent/#returns","title":"Returns","text":"<p>A special key which runs at the <code>observer</code> stage. When applied to an instance, it connects to the event on the instance of the given name. The handler is run with the event's arguments after every firing.</p>"},{"location":"api-reference/instances/onevent/#example-usage","title":"Example Usage","text":"<pre><code>New \"TextButton\" {\n    [OnEvent \"Activated\"] = function(...)\n        print(\"The button was clicked! Arguments:\", ...)\n    end\n}\n</code></pre>"},{"location":"api-reference/instances/out/","title":"Out","text":"Weave Instances"},{"location":"api-reference/instances/out/#out-function-since-v02","title":"Out  function since v0.2","text":"<p>Given a property name, returns a special key which outputs the value of properties with that name. It should be used with a value.</p> <pre><code>(propertyName: string) -&gt; SpecialKey\n</code></pre>"},{"location":"api-reference/instances/out/#parameters","title":"Parameters","text":"<ul> <li><code>propertyName</code> - The name of the property to output the value of.</li> </ul>"},{"location":"api-reference/instances/out/#returns","title":"Returns","text":"<p>A special key which runs at the <code>observer</code> stage. When applied to an instance, it sets the value object equal to the property with the given name. It then listens for further changes and updates the value object accordingly.</p>"},{"location":"api-reference/instances/out/#example-usage","title":"Example Usage","text":"<pre><code>local userText = Value()\n\nNew \"TextBox\" {\n    [Out \"Text\"] = userText\n}\n\nObserver(userText):onChange(function()\n    print(\"The user typed:\", userText:get())\nend)\n</code></pre>"},{"location":"api-reference/instances/ref/","title":"Ref","text":"Weave Instances"},{"location":"api-reference/instances/ref/#ref-special-key-since-v02","title":"Ref  special key since v0.2","text":"<p>When applied to an instance, outputs the instance to a state object. It should be used with a value.</p>"},{"location":"api-reference/instances/ref/#example-usage","title":"Example Usage","text":"<pre><code>local myRef = Value()\n\nNew \"Part\" {\n    [Ref] = myRef\n}\n\nprint(myRef:get()) --&gt; Part\n</code></pre>"},{"location":"api-reference/instances/ref/#technical-details","title":"Technical Details","text":"<p>This special key runs at the <code>observer</code> stage.</p> <p>On cleanup, the state object is reset to nil, in order to avoid potential memory leaks.</p>"},{"location":"api-reference/instances/specialkey/","title":"Specialkey","text":"Weave Instances"},{"location":"api-reference/instances/specialkey/#specialkey-type-since-v02","title":"SpecialKey  type since v0.2","text":"<p>The standard interface for special keys that can be used in property tables for instance processing. Compatible with the New and Hydrate functions.</p> <pre><code>{\n    type: \"SpecialKey\",\n    kind: string,\n    stage: \"self\" | \"descendants\" | \"ancestor\" | \"observer\",\n    apply: (\n        self: SpecialKey,\n        value: any,\n        applyTo: Instance,\n        cleanupTasks: {Task}\n    ) -&gt; ()\n}\n</code></pre>"},{"location":"api-reference/instances/specialkey/#fields","title":"Fields","text":"<ul> <li><code>type</code> - identifies this table as a special key</li> <li><code>kind</code> - gives a developer-friendly name to the object for debugging</li> <li><code>stage</code> - determines when   the special key should apply itself during the hydration process</li> <li><code>apply</code> - the method that will be called to apply the special key to an   instance</li> </ul>"},{"location":"api-reference/instances/specialkey/#example-usage","title":"Example Usage","text":"<pre><code>local Example = {}\nExample.type = \"SpecialKey\"\nExample.kind = \"Example\"\nExample.stage = \"observer\"\n\nfunction Example:apply(value, applyTo, cleanupTasks)\n    local conn = applyTo:GetAttributeChangedSignal(\"Foo\"):Connect(function()\n        print(\"My value is\", value)\n    end)\n    table.insert(cleanupTasks, conn)\nend\n</code></pre>"},{"location":"api-reference/instances/specialkey/#stages","title":"Stages","text":"<p>When using New and Hydrate, properties are applied in the following order:</p> <ol> <li>String keys, except Parent</li> <li>Special keys with <code>stage = \"self\"</code></li> <li>Special keys with <code>stage = \"descendants\"</code></li> <li>Parent, if provided</li> <li>Special keys with <code>stage = \"ancestor\"</code></li> <li>Special keys with <code>stage = \"observer\"</code></li> </ol> <p>There are multiple motivations for splitting special keys into stages like these:</p> <ul> <li>Before we parent descendants to the instance, we want to initialise all of   the instance's properties that don't depend on anything else</li> <li>Before we parent the instance to an ancestor, we want to parent and initialise   all of the instance's descendants as fully as possible</li> <li>Before we attach handlers to anything, we want to parent to and initialise   the instance's ancestor as fully as possible</li> </ul> <p>For these reasons, the roles of each stage are as follows:</p>"},{"location":"api-reference/instances/specialkey/#self","title":"self","text":"<p>The <code>self</code> stage is used for special keys that run before descendants are parented. This is typically used for special keys that operate on the instance itself in a vacuum.</p>"},{"location":"api-reference/instances/specialkey/#descendants","title":"descendants","text":"<p>The <code>descendants</code> stage is used for special keys that need to deal with descendants, but which don't need to know about the ancestry. This is important because parenting descendants after the instance is parented to an ancestor can be more expensive in terms of performance.</p>"},{"location":"api-reference/instances/specialkey/#ancestor","title":"ancestor","text":"<p>The <code>ancestor</code> stage is used for special keys that deal with the ancestor of the instance. This is the last stage that should be used for initialising the instance, and occurs after the Parent has been set.</p>"},{"location":"api-reference/instances/specialkey/#observer","title":"observer","text":"<p>The <code>observer</code> stage is used for special keys that watch the instance for changes or export references to the instance. This stage is where any event handlers should be connected, as initialisation should be done by this point.</p>"},{"location":"api-reference/state/","title":"Index","text":"Weave"},{"location":"api-reference/state/#state","title":"State","text":"<p>Fundamental state objects and utilities for working with reactive graphs.</p>"},{"location":"api-reference/state/#types","title":"Types","text":"<p> CanBeState </p> <p> Dependency </p> <p> Dependent </p> <p> StateObject </p>"},{"location":"api-reference/state/#state-objects","title":"State Objects","text":"<p> Computed </p> <p> ForKeys </p> <p> ForPairs </p> <p> ForValues </p> <p> Observer </p> <p> Value </p>"},{"location":"api-reference/state/canbestate/","title":"Canbestate","text":"Weave State"},{"location":"api-reference/state/canbestate/#canbestate-type-since-v02","title":"CanBeState  type since v0.2","text":"<p>A value which may either be a state object or a constant.</p> <p>Provided as a convenient shorthand for indicating that constant-ness is not important.</p> <pre><code>StateObject&lt;T&gt; | T\n</code></pre>"},{"location":"api-reference/state/canbestate/#example-usage","title":"Example Usage","text":"<pre><code>local function printItem(item: CanBeState&lt;string&gt;)\n    if typeof(item) == \"string\" then\n        -- constant\n        print(\"Got constant: \", item)\n    else\n        -- state object\n        print(\"Got state object: \", item:get())\n    end\nend\n\nlocal constant = \"Hello\"\nlocal state = Value(\"World\")\n\nprintItem(constant) --&gt; Got constant: Hello\nprintItem(state) --&gt; Got state object: World\n</code></pre>"},{"location":"api-reference/state/cleanup/","title":"Cleanup","text":"Weave State"},{"location":"api-reference/state/cleanup/#cleanup-function-since-v02","title":"cleanup  function since v0.2","text":"<p>Attempts to destroy all destructible objects passed to it.</p> <pre><code>(...any) -&gt; ()\n</code></pre>"},{"location":"api-reference/state/cleanup/#parameters","title":"Parameters","text":"<ul> <li><code>...</code> - Any objects that need to be destroyed.</li> </ul>"},{"location":"api-reference/state/cleanup/#example-usage","title":"Example Usage","text":"<pre><code>Fusion.cleanup(\n    workspace.Part1,\n    RunService.RenderStepped:Connect(print),\n    function()\n        print(\"I will be run!\")\n    end\n)\n</code></pre>"},{"location":"api-reference/state/cleanup/#destruction-behaviour","title":"Destruction Behaviour","text":"<p>Destruction behaviour varies by type:</p> <ul> <li>if <code>Instance</code>, <code>:Destroy()</code> is called</li> <li>...else if <code>RBXScriptConnection</code>, <code>:Disconnect()</code> is called</li> <li>...else if <code>function</code>, it is called</li> <li>...else if <code>{destroy: (self) -&gt; ()}</code>, <code>:destroy()</code> is called</li> <li>...else if <code>{Destroy: (self) -&gt; ()}</code>, <code>:Destroy()</code> is called</li> <li>...else if <code>{any}</code>, <code>Fusion.cleanup</code> is called on all members</li> <li>...else nothing occurs.</li> </ul>"},{"location":"api-reference/state/computed/","title":"Computed","text":"Weave State"},{"location":"api-reference/state/computed/#computed-state-object-since-v01","title":"Computed  state object since v0.1","text":"<p>Calculates a single value based on the returned values from other state objects.</p> <pre><code>(\n    processor: () -&gt; (T, M),\n    destructor: ((T, M) -&gt; ())?\n) -&gt; Computed&lt;T, M&gt;\n</code></pre>"},{"location":"api-reference/state/computed/#parameters","title":"Parameters","text":"<ul> <li> <p><code>processor: () -&gt; (T, M)</code> - computes and returns values to be returned from   the computed object, optionally returning extra values for the destructor alone</p> </li> <li> <p><code>destructor: ((T, M) -&gt; ())?</code> - disposes of values generated by <code>processor</code>   when they are no longer in use</p> </li> </ul>"},{"location":"api-reference/state/computed/#object-methods","title":"Object Methods","text":"<p> since v0.1 </p>"},{"location":"api-reference/state/computed/#computedget","title":"Computed:get()","text":"<p>Returns the current value stored in the state object.</p> <p>If dependencies are being captured (e.g. inside a computed callback), this state object will also be added as a dependency.</p> <pre><code>(asDependency: boolean?) -&gt; T\n</code></pre>"},{"location":"api-reference/state/computed/#example-usage","title":"Example Usage","text":"<pre><code>local numCoins = State(50)\n\nlocal doubleCoins = Computed(function()\n    return numCoins:get() * 2\nend)\n\nprint(doubleCoins:get()) --&gt; 100\n\nnumCoins:set(2)\nprint(doubleCoins:get()) --&gt; 4\n</code></pre>"},{"location":"api-reference/state/computed/#dependency-management","title":"Dependency Management","text":"<p>Computed objects automatically detect dependencies used inside their callback each time their callback runs. This means, when you use a function like <code>:get()</code> on a state object, it will register that state object as a dependency:</p> <pre><code>local numCoins = Value(50)\n\nlocal doubleCoins = Computed(function()\n    -- Weave detects you called :get() on `numCoins`, and so adds `numCoins` as\n    -- a dependency of this computed object.\n    return numCoins:get() * 2\nend)\n</code></pre> <p>When a dependency changes value, the computed object will re-run its callback to generate and cache the current value internally. This value is later exposed via the <code>:get()</code> method.</p> <p>Something to note is that dependencies are dynamic; you can change what values your computed object depends on, and the dependencies will be updated to reduce unnecessary updates:</p> Lua <pre><code>local stateA = Value(5)\nlocal stateB = Value(5)\nlocal selector = Value(\"A\")\n\n    local computed = Computed(function()\n        print(\"&gt; updating computed!\")\n        local selected = selector:get()\n        if selected == \"A\" then\n            return stateA:get()\n        elseif selected == \"B\" then\n            return stateB:get()\n        end\n    end)\n\n    print(\"increment state A (expect update below)\")\n    stateA:set(stateA:get() + 1)\n    print(\"increment state B (expect no update)\")\n    stateA:set(stateA:get() + 1)\n\n    print(\"switch to select B\")\n    selector:set(\"B\")\n\n    print(\"increment state A (expect no update)\")\n    stateA:set(stateA:get() + 1)\n    print(\"increment state B (expect update below)\")\n    stateA:set(stateA:get() + 1)\n    ```\n\n=== \"Expected output\"\n`\n    &gt; updating computed!\n    increment state A (expect update below)\n    &gt; updating computed!\n    increment state B (expect no update)\n    switch to select B\n    &gt; updating computed!\n    increment state A (expect no update)\n    increment state B (expect update below)\n    &gt; updating computed!\n    `\n\n!!! caution \"Pitfall: using non-state values\"\nStick to using state objects and computed objects inside your computations.\nWeave can detect when you use these objects and listen for changes.\n\n    Weave *can't* automatically detect changes when you use 'normal' variables:\n\n    ```luau\n    local theVariable = \"Hello\"\n    local badValue = Computed(function()\n        -- don't do this! use state objects or computed objects in here\n        return \"Say \" .. theVariable\n    end)\n\n    print(badValue:get()) -- prints 'Say Hello'\n\n    theVariable = \"World\"\n    print(badValue:get()) -- still prints 'Say Hello' - that's a problem!\n    ```\n\n    By using a state object here, Weave can correctly update the computed\n    object, because it knows you used the state object:\n\n    ```luau\n    local theVariable = Value(\"Hello\")\n    local goodValue = Computed(function()\n        -- this is much better - Weave can detect you used this state object!\n        return \"Say \" .. theVariable:get()\n    end)\n\n    print(goodValue:get()) -- prints 'Say Hello'\n\n    theVariable:set(\"World\")\n    print(goodValue:get()) -- prints 'Say World'\n    ```\n\n    This also applies to any functions that change on their own, like\n    `os.clock()`. If you need to use them, store values from the function in a\n    state object, and update the value of that object as often as required.\n\n---\n\n## Destructors\n\nThe `destructor` callback, if provided, is called when the computed object swaps\nout an old value for a newly-generated one. It is called with the old value as\nthe first parameter, and - if provided - an extra value returned from `processor`\nas a customisable second parameter.\n\nDestructors are required when working with data types that require destruction,\nsuch as instances. Otherwise, they are optional, so not all calculations have to\nspecify destruction behaviour.\n\nWeave guarantees that values passed to destructors by default will never be\nused again by the library, so it is safe to finalise them. This does not apply\nto the customisable second parameter, which the user is responsible for handling\nproperly.\n</code></pre>"},{"location":"api-reference/state/dependency/","title":"Dependency","text":"Weave State"},{"location":"api-reference/state/dependency/#dependency-type-since-v02","title":"Dependency  type since v0.2","text":"<p>A graph object which can send updates to dependents on the reactive graph.</p> <p>Most often used with state objects, though the reactive graph does not require objects to store state.</p> <pre><code>{\n    dependentSet: Set&lt;Dependent&gt;\n}\n</code></pre>"},{"location":"api-reference/state/dependency/#example-usage","title":"Example Usage","text":"<pre><code>-- these are examples of objects which are dependencies\nlocal value: Dependency = Value(2)\nlocal computed: Dependency = Computed(function()\n    return value:get() * 2\nend)\n\n-- dependencies can be used with some internal functions such as updateAll()\nupdateAll(value)\n</code></pre>"},{"location":"api-reference/state/dependency/#automatic-dependency-manager","title":"Automatic Dependency Manager","text":"<p>Weave includes an automatic dependency manager which can detect when graph objects are used in certain contexts and automatically form reactive graphs.</p> <p>In order to do this, dependencies should signal to the system when they are being used (for example, during a call to a <code>:get()</code> method). This can be done via the <code>useDependency()</code> function internally, which should be called with the dependency object.</p> <p>Furthermore, to help assist the dependency manager prevent cycles in the reactive graph, dependencies should register themselves with the system as soon as they are created via the <code>initDependency()</code> function internally. This is primarily used to prevent dependencies from being captured when they originate from within the object which is doing the capturing.</p>"},{"location":"api-reference/state/dependent/","title":"Dependent","text":"Weave State"},{"location":"api-reference/state/dependent/#dependent-type-since-v02","title":"Dependent  type since v0.2","text":"<p>A graph object which can receive updates from dependecies on the reactive graph.</p> <p>Most often used with state objects, though the reactive graph does not require objects to store state.</p> <pre><code>{\n    dependencySet: Set&lt;Dependency&gt;,\n    update: (self) -&gt; boolean\n}\n</code></pre>"},{"location":"api-reference/state/dependent/#fields","title":"Fields","text":"<ul> <li><code>dependencySet</code> - stores the graph objects which this object can receive   updates from</li> </ul>"},{"location":"api-reference/state/dependent/#methods","title":"Methods","text":"<p> since v0.2 </p>"},{"location":"api-reference/state/dependent/#dependentupdate","title":"Dependent:update()","text":"<p>Called when this object receives an update from one or more dependencies.</p> <p>If this object is a dependency, and updates should be propagated to further dependencies, this method should return true. Otherwise, to block further updates from occuring (for example, because this object did not change value), this method should return false.</p> <pre><code>() -&gt; boolean\n</code></pre>"},{"location":"api-reference/state/dependent/#example-usage","title":"Example Usage","text":"<pre><code>-- these are examples of objects which are dependents\nlocal computed: Dependent = Computed(function()\n    return \"foo\"\nend)\nlocal observer: Dependent = Observer(computed)\n</code></pre>"},{"location":"api-reference/state/dependent/#automatic-dependency-manager","title":"Automatic Dependency Manager","text":"<p>Weave includes an automatic dependency manager which can detect when graph objects are used in certain contexts and automatically form reactive graphs.</p> <p>If a dependent wants to automatically capture uses of dependencies inside of certain contexts (for example, a processor callback) then the <code>captureDependencies()</code> function may be invoked, with the callback and the object's dependency set as arguments.</p> <p>This will detect all <code>useDependency()</code> calls from inside the callback, and save any passed dependencies into the set.</p>"},{"location":"api-reference/state/doNothing/","title":"doNothing","text":"Weave State"},{"location":"api-reference/state/doNothing/#donothing-function-since-v02","title":"doNothing  function since v0.2","text":"<p>No-op function - does nothing at all, and returns nothing at all. Intended for use as a destructor when no destruction is needed.</p> <pre><code>(...any) -&gt; ()\n</code></pre>"},{"location":"api-reference/state/doNothing/#parameters","title":"Parameters","text":"<ul> <li><code>...</code> - Any objects.</li> </ul>"},{"location":"api-reference/state/doNothing/#example-usage","title":"Example Usage","text":"<pre><code>local foo = Computed(function()\n    return workspace.Part\nend, Weave.doNothing)\n</code></pre>"},{"location":"api-reference/state/forkeys/","title":"Forkeys","text":"Weave State"},{"location":"api-reference/state/forkeys/#forkeys-state-object-since-v02","title":"ForKeys  state object since v0.2","text":"<p>Processes a table from another state object by transforming its keys only.</p> <pre><code>(\n    input: CanBeState&lt;{[KI]: V}&gt;,\n    keyProcessor: (KI, M) -&gt; (KO, M),\n    keyDestructor: ((KO, M) -&gt; ())?\n) -&gt; ForKeys&lt;KI, KO, V, M&gt;\n</code></pre>"},{"location":"api-reference/state/forkeys/#parameters","title":"Parameters","text":"<ul> <li><code>input: CanBeState&lt;{[KI]: V}&gt;</code> - the table to be processed, either as a state   object or a constant value</li> <li><code>keyProcessor: (KI, M) -&gt; (KO, M)</code> - transforms input keys into new   keys, optionally providing metadata for the destructor alone</li> <li><code>keyDestructor: ((KO, M) -&gt; ())?</code> - disposes of values generated by   <code>keyProcessor</code> when they are no longer in use</li> </ul>"},{"location":"api-reference/state/forkeys/#object-methods","title":"Object Methods","text":"<p> since v0.2 </p>"},{"location":"api-reference/state/forkeys/#forkeysget","title":"ForKeys:get()","text":"<p>Returns the current value stored in the state object.</p> <p>If dependencies are being captured (e.g. inside a computed callback), this state object will also be added as a dependency.</p> <pre><code>(asDependency: boolean?) -&gt; {[KO]: V}\n</code></pre>"},{"location":"api-reference/state/forkeys/#example-usage","title":"Example Usage","text":"<pre><code>local data = Value({\n    one = 1,\n    two = 2,\n    three = 3,\n    four = 4\n})\n\nlocal transformed = ForKeys(data, function(key)\n    local newKey = string.upper(key)\n    return newKey\nend)\n\nprint(transformed:get()) --&gt; {ONE = 1, TWO = 2 ... }\n</code></pre>"},{"location":"api-reference/state/forkeys/#dependency-management","title":"Dependency Management","text":"<p>ForKeys objects automatically detect dependencies used inside their callback each time their callback runs. This means, when you use a function like <code>:get()</code> on a state object, it will register that state object as a dependency:</p> <pre><code>local multiplier = Value(2)\nlocal data = Value({1, 2, 3, 4, 5})\n\nlocal scaledData = ForKeys(data, function(key)\n    -- Weave detects you called :get() on `multiplier`, and so adds `multiplier`\n    -- as a dependency specifically for this key.\n    return key * multiplier:get()\nend)\n</code></pre> <p>When that dependency changes value, the specific keys using that value are recalculated.</p> <p>See the Computed docs for specifics on how dependency management works.</p>"},{"location":"api-reference/state/forkeys/#destructors","title":"Destructors","text":"<p>The <code>keyDestructor</code> callback, if provided, is called when this object swaps out an old key for a newly-generated one. It is called with the old key as the first parameter, and - if provided - an extra value returned from <code>keyProcessor</code> as a customisable second parameter.</p> <p>Destructors are required when working with data types that require destruction, such as instances. Otherwise, they are optional, so not all calculations have to specify destruction behaviour.</p> <p>Weave guarantees that values passed to destructors by default will never be used again by the library, so it is safe to finalise them. This does not apply to the customisable second parameter, which the user is responsible for handling properly.</p>"},{"location":"api-reference/state/forkeys/#optimisations","title":"Optimisations","text":"<p>ForKeys does not allow access to the values of the input table. This guarantees that all generated keys are completely independent of any values. This means keys only need to be calculated when they're added to the input table - all other changes are simply forwarded to the output table. Since keys are also unique, all calculations are unique, so caching and reuse are not required.</p>"},{"location":"api-reference/state/forpairs/","title":"Forpairs","text":"Weave State"},{"location":"api-reference/state/forpairs/#forpairs-state-object-since-v02","title":"ForPairs  state object since v0.2","text":"<p>Processes a table from another state object by transforming its keys and values.</p> <pre><code>(\n    input: CanBeState&lt;{[KI]: VI}&gt;,\n    pairProcessor: (KI, VI, M) -&gt; (KO, VO, M),\n    pairDestructor: ((KO, VO, M) -&gt; ())?\n) -&gt; ForPairs&lt;KI, VI, KO, VO, M&gt;\n</code></pre>"},{"location":"api-reference/state/forpairs/#parameters","title":"Parameters","text":"<ul> <li><code>input: CanBeState&lt;{[KI]: VI}&gt;</code> - the table to be processed, either as a state   object or a constant value</li> <li><code>pairProcessor: (KI, VI, M) -&gt; (KO, VO, M)</code> - transforms input key-value pairs   into new key-value pairs, optionally providing metadata for the destructor alone</li> <li><code>pairDestructor: ((KO, VO, M) -&gt; ())?</code> - disposes of values generated by   <code>pairProcessor</code> when they are no longer in use</li> </ul>"},{"location":"api-reference/state/forpairs/#object-methods","title":"Object Methods","text":"<p> since v0.2 </p>"},{"location":"api-reference/state/forpairs/#forpairsget","title":"ForPairs:get()","text":"<p>Returns the current value stored in the state object.</p> <p>If dependencies are being captured (e.g. inside a computed callback), this state object will also be added as a dependency.</p> <pre><code>(asDependency: boolean?) -&gt; {[KO]: VO}\n</code></pre>"},{"location":"api-reference/state/forpairs/#example-usage","title":"Example Usage","text":"<pre><code>local data = Value({\n    one = 1,\n    two = 2,\n    three = 3,\n    four = 4\n})\n\nlocal transformed = ForPairs(data, function(key, value)\n    local newKey = value\n    local newValue = string.upper(key)\n    return newKey, newValue\nend)\n\nprint(transformed:get()) --&gt; {[1] = \"ONE\", [2] = \"TWO\" ... }\n</code></pre>"},{"location":"api-reference/state/forpairs/#dependency-management","title":"Dependency Management","text":"<p>ForPairs objects automatically detect dependencies used inside their callback each time their callback runs. This means, when you use a function like <code>:get()</code> on a state object, it will register that state object as a dependency:</p> <pre><code>local multiplier = Value(2)\nlocal data = Value({1, 2, 3, 4, 5})\n\nlocal scaledData = ForPairs(data, function(key, value)\n    -- Weave detects you called :get() on `multiplier`, and so adds `multiplier`\n    -- as a dependency specifically for this key-value pair.\n    return key * multiplier:get(), value * multiplier:get()\nend)\n</code></pre> <p>When that dependency changes value, the specific key-value pairs using that value are recalculated.</p> <p>See the Computed docs for specifics on how dependency management works.</p>"},{"location":"api-reference/state/forpairs/#destructors","title":"Destructors","text":"<p>The <code>pairDestructor</code> callback, if provided, is called when this object swaps out an old key-value pair for a newly-generated one. It is called with the old pair as the first and second parameters, and - if provided - an extra value returned from <code>pairProcessor</code> as a customisable third parameter.</p> <p>Destructors are required when working with data types that require destruction, such as instances. Otherwise, they are optional, so not all calculations have to specify destruction behaviour.</p> <p>Weave guarantees that values passed to destructors by default will never be used again by the library, so it is safe to finalise them. This does not apply to the customisable third parameter, which the user is responsible for handling properly.</p>"},{"location":"api-reference/state/forpairs/#optimisations","title":"Optimisations","text":"<p>ForPairs is the least restrictive of the For objects, allowing full access to the key-value pairs being processed. This means that very little optimisation is applied - values are always locked to the specific key they were generated for, and any change in the input's key or value will prompt a recalculation.</p> <p>For other optimisations, consider using ForValues or ForKeys, which impose stricter restrictions to allow for less frequent updates and greater reuse.</p>"},{"location":"api-reference/state/forvalues/","title":"Forvalues","text":"Weave State"},{"location":"api-reference/state/forvalues/#forvalues-state-object-since-v02","title":"ForValues  state object since v0.2","text":"<p>Processes a table from another state object by transforming its values only.</p> <pre><code>(\n    input: CanBeState&lt;{[K]: VI}&gt;,\n    valueProcessor: (VI, M) -&gt; (VO, M),\n    valueDestructor: ((VO, M) -&gt; ())?\n) -&gt; ForValues&lt;K, VI, VO, M&gt;\n</code></pre>"},{"location":"api-reference/state/forvalues/#parameters","title":"Parameters","text":"<ul> <li><code>input: CanBeState&lt;{[K]: VI}&gt;</code> - the table to be processed, either as a state   object or a constant value</li> <li><code>valueProcessor: (VI, M) -&gt; (VO, M)</code> - transforms input values into new values,   optionally providing metadata for the destructor alone</li> <li><code>valueDestructor: ((VO, M) -&gt; ())?</code> - disposes of values generated by   <code>valueProcessor</code> when they are no longer in use</li> </ul>"},{"location":"api-reference/state/forvalues/#object-methods","title":"Object Methods","text":"<p> since v0.2 </p>"},{"location":"api-reference/state/forvalues/#forvaluesget","title":"ForValues:get()","text":"<p>Returns the current value stored in the state object.</p> <p>If dependencies are being captured (e.g. inside a computed callback), this state object will also be added as a dependency.</p> <pre><code>(asDependency: boolean?) -&gt; {[K]: VO}\n</code></pre>"},{"location":"api-reference/state/forvalues/#example-usage","title":"Example Usage","text":"<pre><code>local data = Value({\n    one = 1,\n    two = 2,\n    three = 3,\n    four = 4\n})\n\nlocal transformed = ForValues(data, function(value)\n    local newValue = value * 2\n    return newValue\nend)\n\nprint(transformed:get()) --&gt; {ONE = 2, TWO = 4 ... }\n</code></pre>"},{"location":"api-reference/state/forvalues/#dependency-management","title":"Dependency Management","text":"<p>ForValues objects automatically detect dependencies used inside their callback each time their callback runs. This means, when you use a function like <code>:get()</code> on a state object, it will register that state object as a dependency:</p> <pre><code>local multiplier = Value(2)\nlocal data = Value({1, 2, 3, 4, 5})\n\nlocal scaledData = ForValues(data, function(value)\n    -- Weave detects you called :get() on `multiplier`, and so adds `multiplier`\n    -- as a dependency specifically for this value.\n    return value * multiplier:get()\nend)\n</code></pre> <p>When that dependency changes value, the specific values using that dependency are recalculated.</p> <p>See the Computed docs for specifics on how dependency management works.</p>"},{"location":"api-reference/state/forvalues/#destructors","title":"Destructors","text":"<p>The <code>valueDestructor</code> callback, if provided, is called when this object swaps out an old value for a newly-generated one. It is called with the old value as the first parameter, and - if provided - an extra value returned from <code>valueProcessor</code> as a customisable second parameter.</p> <p>Destructors are required when working with data types that require destruction, such as instances. Otherwise, they are optional, so not all calculations have to specify destruction behaviour.</p> <p>Weave guarantees that values passed to destructors by default will never be used again by the library, so it is safe to finalise them. This does not apply to the customisable second parameter, which the user is responsible for handling properly.</p>"},{"location":"api-reference/state/forvalues/#optimisations","title":"Optimisations","text":"<p>ForValues does not allow access to the keys of the input table. This guarantees that all generated values are completely independent of the key they were generated for. This means that values may be moved between keys instead of being destroyed when their original key changes value. Values are only reused once - values aren't copied when there are multiple occurences of the same input.</p>"},{"location":"api-reference/state/observer/","title":"Observer","text":"Weave State"},{"location":"api-reference/state/observer/#observer-graph-object-since-v02","title":"Observer  graph object since v0.2","text":"<p>Observes various updates and events on a given dependency.</p> <pre><code>(\n    observe: Dependency\n) -&gt; Observer\n</code></pre>"},{"location":"api-reference/state/observer/#parameters","title":"Parameters","text":"<ul> <li><code>observe: Dependency</code> - the dependency this observer should respond to</li> </ul>"},{"location":"api-reference/state/observer/#object-methods","title":"Object Methods","text":"<p> since v0.2 </p>"},{"location":"api-reference/state/observer/#observeronchange","title":"Observer:onChange()","text":"<p>Connects the given callback as a change handler, and returns a function which will disconnect the callback. The callback will run whenever the observed dependency is updated.</p> <pre><code>(callback: () -&gt; ()) -&gt; (() -&gt; ())\n</code></pre>"},{"location":"api-reference/state/observer/#parameters_1","title":"Parameters","text":"<ul> <li><code>callback</code> - The function to call when a change is observed</li> </ul> <p>Connection memory leaks</p> <p>Make sure to disconnect any change handlers made using this function once you're done using them.</p> <pre><code>As long as a change handler is connected, this observer and the dependency\nit observes will be held in memory in case further changes occur. This means,\nif you don't call the disconnect function, you may end up accidentally\nholding your state objects in memory forever after you're done using them.\n</code></pre>"},{"location":"api-reference/state/observer/#example-usage","title":"Example Usage","text":"<pre><code>local numCoins = Value(50)\n\nlocal coinObserver = Observer(numCoins)\n\nlocal disconnect = coinObserver:onChange(function()\n    print(\"coins is now:\", numCoins:get())\nend)\n\nnumCoins:set(25) -- prints 'coins is now: 25'\n\n-- always clean up your connections!\ndisconnect()\n</code></pre>"},{"location":"api-reference/state/stateobject/","title":"Stateobject","text":"Weave State"},{"location":"api-reference/state/stateobject/#stateobject-type-since-v02","title":"StateObject  type since v0.2","text":"<p>A dependency that provides a single stateful value; the dependency updates when the value changes state.</p> <pre><code>Dependency &amp; {\n    type: \"State\",\n    kind: string,\n    get: (self, asDependency: boolean?) -&gt; T\n}\n</code></pre>"},{"location":"api-reference/state/stateobject/#fields","title":"Fields","text":"<ul> <li><code>type</code> - uniquely identifies state objects for runtime type checks</li> <li><code>kind</code> - holds a more specific type name for different kinds of state object</li> </ul>"},{"location":"api-reference/state/stateobject/#methods","title":"Methods","text":"<p> since v0.1 </p>"},{"location":"api-reference/state/stateobject/#stateobjectget","title":"StateObject:get()","text":"<p>Returns the current value stored in the state object.</p> <p>If dependencies are being captured (e.g. inside a computed callback), this state object will also be added as a dependency.</p> <pre><code>(asDependency: boolean?) -&gt; T\n</code></pre>"},{"location":"api-reference/state/stateobject/#example-usage","title":"Example Usage","text":"<pre><code>-- these are examples of objects which are state objects\nlocal computed: StateObject = Computed(function()\n    return \"foo\"\nend)\nlocal observer: StateObject = Observer(computed)\n</code></pre>"},{"location":"api-reference/state/stateobject/#automatic-dependency-manager","title":"Automatic Dependency Manager","text":"<p>Fusion includes an automatic dependency manager which can detect when graph objects are used in certain contexts and automatically form reactive graphs.</p> <p>In order to do this, state objects should signal to the system when they are being used. This can be done via the <code>useDependency()</code> function internally, which should be called with the state object as the argument during execution of the <code>:get()</code> method.</p> <p>Furthermore, to help assist the dependency manager prevent cycles in the reactive graph, state objects should register themselves with the system as soon as they are created via the <code>initDependency()</code> function internally. This is primarily used to prevent dependencies from being captured when they originate from within the object which is doing the capturing.</p>"},{"location":"api-reference/state/value/","title":"Value","text":"Weave State"},{"location":"api-reference/state/value/#value-state-object-since-v02","title":"Value  state object since v0.2","text":"<p>Stores a single value which can be updated at any time.</p> <pre><code>(\n    initialValue: T\n) -&gt; Value&lt;T&gt;\n</code></pre>"},{"location":"api-reference/state/value/#parameters","title":"Parameters","text":"<ul> <li><code>initialValue</code> - The value that should be initially stored after construction.</li> </ul>"},{"location":"api-reference/state/value/#methods","title":"Methods","text":"<p> since v0.2 </p>"},{"location":"api-reference/state/value/#valueget","title":"Value:get()","text":"<p>Returns the current value stored in the state object.</p> <p>If dependencies are being captured (e.g. inside a computed callback), this state object will also be added as a dependency.</p> <pre><code>(asDependency: boolean?) -&gt; T\n</code></pre>"},{"location":"api-reference/state/value/#parameters_1","title":"Parameters","text":"<ul> <li><code>asDependency</code> - If this is explicitly set to false, no dependencies will be   captured.</li> </ul> <p> since v0.2 </p>"},{"location":"api-reference/state/value/#valueset","title":"Value:set()","text":"<p>Replaces the currently stored value, updating any other state objects that depend on this value object. The value is stored directly, and no cloning or alteration is done.</p> <p>If the new value is the same as the old value, other state objects won't be updated.</p> <pre><code>(newValue: T) -&gt; ()\n</code></pre>"},{"location":"api-reference/state/value/#parameters_2","title":"Parameters","text":"<ul> <li><code>newValue</code> - The new value to be stored.</li> </ul> Table sameness <p>Updates are always sent out when setting a table value, because it's much more difficult to evaluate if two tables are the same. Therefore, this method is conservative and labels all tables as different, even compared to themselves.</p> Legacy parameter: force <p>Originally, a second <code>force</code> parameter was available in Fusion 0.1 so that updates could forcibly be sent out, even when the new value was the same as the old value. This is because Fusion 0.1 used equality to evaluate sameness for all data types, including tables. This was problematic as many users attempted to <code>:get()</code> the table value, modify it, and <code>:set()</code> it back into the object, which would not cause an update as the table reference did not change.</p> <pre><code>Fusion 0.2 uses a different sameness definition for tables to alleviate this\nproblem. As such, there is no longer a good reason to use this parameter,\nand so it is not currently recommended for use. For backwards compatibility,\nit will remain for the time being, but do not depend on it for new work.\n</code></pre>"},{"location":"api-reference/state/value/#example-usage","title":"Example Usage","text":"<pre><code>local numCoins = Value(50) -- start off with 50 coins\nprint(numCoins:get()) --&gt; 50\n\nnumCoins:set(10)\nprint(numCoins:get()) --&gt; 10\n</code></pre>"},{"location":"examples/","title":"Examples","text":"<p>Welcome to the Examples section! Here, you can find various open-source examples and projects, so you can see how Fusion works in a real setting.</p>"},{"location":"examples/#the-cookbook","title":"The Cookbook","text":"<p>Oftentimes, you might be stuck on a small problem. You want to create something specific, but don't know how to do it with Fusion's tools.</p> <p>The cookbook can help with that! It's a collection of snippets which show you how to do various small tasks with Fusion, like processing arrays, applying animations and responding to different events.</p> <p>Visit the cookbook to see what's available.</p>"},{"location":"examples/#open-source-projects","title":"Open-Source Projects","text":""},{"location":"examples/#fusion-wordle","title":"Fusion Wordle","text":"<p>See how Fusion can be used to build a mobile-first UI-centric game, with server validation, spring animations and sounds.</p> <p>Play and edit the game on Roblox.</p>"},{"location":"examples/#fusion-obby","title":"Fusion Obby","text":"<p>See how Fusion can be used to build a minimal interface for an obby, with an animated checkpoint counter and simulated confetti.</p> <p>Play and edit the game on Roblox.</p>"},{"location":"examples/cookbook/","title":"Cookbook","text":"<p>Oftentimes, you might be stuck on a small problem. You want to create something specific, but don't know how to do it with Fusion's tools.</p> <p>The cookbook can help with that! It's a collection of snippets which show you how to do various small tasks with Fusion, like processing arrays, applying animations and responding to different events.</p>"},{"location":"examples/cookbook/#navigation","title":"Navigation","text":"<p>Using the sidebar to the left, you can browse all of the cookbook examples by name.</p>"},{"location":"examples/cookbook/animated-computed/","title":"Animated computed","text":"<pre><code>-- [Weave imports omitted for clarity]\n\n-- Oftentimes we calculate values for a single purpose, such as the position of\n-- a single UI element. These values are often calculated inline, like this:\n\nlocal menuBar = New \"Frame\" {\n    AnchorPoint = Computed(function()\n        return if menuIsOpen:get() then Vector2.new(0.5, 0) else Vector2.new(0.5, -1)\n    end)\n}\n\n-- If you want to animate these inline values, you can pass them through an\n-- object such as Spring and Tween- you don't have to do it separately.\n\nlocal menuBar = New \"Frame\" {\n    -- Use tweens for highly controllable animations:\n    AnchorPoint = Tween(Computed(function()\n        return if menuIsOpen:get() then Vector2.new(0.5, 0) else Vector2.new(0.5, -1)\n    end), TweenInfo.new(0.2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut)),\n\n    -- Or use springs for more natural and responsive movement:\n    AnchorPoint = Spring(Computed(function()\n        return if menuIsOpen:get() then Vector2.new(0.5, 0) else Vector2.new(0.5, -1)\n    end), 20, 0.5)\n}\n\n-- The equivalent 'expanded' code looks like this:\n\nlocal anchorPoint = Computed(function()\n    return if menuIsOpen:get() then Vector2.new(0.5, 0) else Vector2.new(0.5, -1)\nend)\n\nlocal smoothAnchorPoint = Spring(anchorPoint, 20, 0.5) -- or equivalent Tween\n\nlocal menuBar = New \"Frame\" {\n    AnchorPoint = smoothAnchorPoint\n}\n\n-- Keep in mind that you probably shouldn't use inline animation for everything.\n-- Sometimes you need to use the expanded form, or the expanded form would be\n-- more efficient, and that's okay - choose what works best for your code :)\n</code></pre>"},{"location":"examples/cookbook/button-component/","title":"Button component","text":"<pre><code>-- [Weave imports omitted for clarity]\n\n-- This is a relatively complete example of a button component.\n-- It handles many common interactions such as hovering and clicking.\n\n-- This should be a generally useful template for assembling components of your\n-- own. Unless you're prototyping, it's probably wise to stick to some good\n-- guidelines; the Tutorials have some tips if you don't have any existing\n-- guidelines of your own.\n\n-- Defining the names of properties the button accepts, and their types. This is\n-- useful for autocomplete and helps catch some typos, but is optional.\nexport type Props = {\n    -- some generic properties we'll allow other code to control directly\n    Name: CanBeState&lt;string&gt;?,\n    LayoutOrder: CanBeState&lt;number&gt;?,\n    Position: CanBeState&lt;UDim2&gt;?,\n    AnchorPoint: CanBeState&lt;Vector2&gt;?,\n    Size: CanBeState&lt;UDim2&gt;?,\n    AutomaticSize: CanBeState&lt;Enum.AutomaticSize&gt;?,\n    ZIndex: CanBeState&lt;number&gt;?,\n\n    -- button-specific properties\n    Text: CanBeState&lt;string&gt;?,\n    OnClick: (() -&gt; ())?,\n    Disabled: CanBeState&lt;boolean&gt;?\n}\n\n-- Returns `Child` to match Weave's `Component` type. This should work for most\n-- use cases, and offers the greatest encapsulation as you're able to swap out\n-- your return type for an array or state object if you want to.\nlocal function Button(props: Props): Child\n    -- To simplify our code later (because we're going to operate on this value)\n    if props.Disabled == nil then\n        props.Disabled = Value(false)\n    elseif typeof(props.Disabled) == \"boolean\" then\n        props.Disabled = Value(props.Disabled)\n    end\n\n    -- We should generally be careful about storing state in widely reused\n    -- components, as the Tutorials explain, but for contained use cases such as\n    -- hover states, it should be perfectly fine.\n    local isHovering = Value(false)\n    local isHeldDown = Value(false)\n\n    return New \"TextButton\" {\n        Name = props.Name,\n        LayoutOrder = props.LayoutOrder,\n        Position = props.Position,\n        AnchorPoint = props.AnchorPoint,\n        Size = props.Size,\n        AutomaticSize = props.AutomaticSize,\n        ZIndex = props.ZIndex,\n\n        Text = props.Text,\n        TextColor3 = Color3.fromHex(\"FFFFFF\"),\n\n        BackgroundColor3 = Spring(Computed(function()\n            if props.Disabled:get() then\n                return Color3.fromHex(\"CCCCCC\")\n            else\n                local baseColour = Color3.fromHex(\"0085FF\")\n                -- darken/lighten when hovered or held down\n                if isHeldDown:get() then\n                    baseColour = baseColour:Lerp(Color3.new(0, 0, 0), 0.25)\n                elseif isHovering:get() then\n                    baseColour = baseColour:Lerp(Color3.new(1, 1, 1), 0.25)\n                end\n                return baseColour\n            end\n        end), 20),\n\n        [OnEvent \"Activated\"] = function()\n            -- Because we're not in a Computed callback (or similar), it's a\n            -- good idea to :get(false) so we're not adding any dependencies\n            -- anywhere.\n            if props.OnClick ~= nil and not props.Disabled:get(false) then\n                -- We're explicitly calling this function with no arguments to\n                -- match the types we specified above. If we just passed it\n                -- straight into the event, the function would receive arguments\n                -- from the Activated event, which might not be desirable.\n                props.OnClick()\n            end\n        end,\n\n        [OnEvent \"MouseButton1Down\"] = function()\n            isHeldDown:set(true) -- it's good UX to give immediate feedback\n        end,\n\n        [OnEvent \"MouseButton1Up\"] = function()\n            isHeldDown:set(false)\n        end,\n\n        [OnEvent \"MouseEnter\"] = function()\n            -- Roblox calls this event even if the button is being covered by\n            -- other UI. For simplicity, we won't worry about that.\n            isHovering:set(true)\n        end,\n\n        [OnEvent \"MouseLeave\"] = function()\n            isHovering:set(false)\n            -- If the button is being held down, but the cursor moves off the\n            -- button, then we won't receive the mouse up event. To make sure\n            -- the button doesn't get stuck held down, we'll release it if the\n            -- cursor leaves the button.\n            isHeldDown:set(false)\n        end,\n\n        [Children] = {\n            New \"UICorner\" {\n                CornerRadius = UDim.new(0, 4)\n            },\n\n            New \"UIPadding\" {\n                PaddingTop = UDim.new(0, 6),\n                PaddingBottom = UDim.new(0, 6),\n                PaddingLeft = UDim.new(0, 6),\n                PaddingRight = UDim.new(0, 6)\n            }\n        }\n    }\nend\n\nreturn Button\n</code></pre>"},{"location":"examples/cookbook/drag-and-drop/","title":"Drag and drop","text":"<pre><code>local GuiService = game:GetService(\"GuiService\")\nlocal HttpService = game:GetService(\"HttpService\")\nlocal UserInputService = game:GetService(\"UserInputService\")\n-- [Weave imports omitted for clarity]\n\n-- This example shows a full drag-and-drop implementation for mouse input only.\n-- Extending this system to generically work with other input types, such as\n-- touch gestures or gamepads, is left as an exercise to the reader. However, it\n-- should robustly support dragging many types of UI around flexibly.\n\n-- To ensure best accessibility, any interactions you implement shouldn't force\n-- the player to hold the mouse button down. Either allow drag-and-drop using\n-- single inputs, or provide a non-dragging alternative; this will ensure that\n-- players with reduced motor ability aren't locked out of UI functions.\n\n-- We're going to need to account for the UI inset sometimes. We cache it here.\nlocal TOP_LEFT_INSET = GuiService:GetGuiInset()\n\n-- To reflect the current position of the cursor on-screen, we'll use a state\n-- object that's updated using UserInputService.\nlocal mousePos = Value(UserInputService:GetMouseLocation() - TOP_LEFT_INSET)\nlocal mousePosConn = UserInputService.InputChanged:Connect(function(inputObject)\n    if inputObject.UserInputType == Enum.UserInputType.MouseMovement then\n        mousePos:set(Vector2.new(inputObject.Position.X, inputObject.Position.Y))\n    end\nend)\n\n-- We need to keep drag of which item is currently being dragged. Only one item\n-- can be dragged at a time. This type stores all the information needed:\nexport type CurrentlyDragging = {\n    -- Each draggable item will have a unique ID; the ID stored here represents\n    -- which item is being dragged right now. We'll use strings for this, but\n    -- you could use numbers if that's more convenient for you.\n    id: string,\n    -- When a drag is started, we store the mouse's offset relative to the item\n    -- being dragged. When the mouse moves, we can then apply the same offset to\n    -- make it look like the item is 'pinned' to the cursor.\n    offset: Vector2\n}\n-- This state object stores the above during a drag, or `nil` when not dragging.\nlocal currentlyDragging = Value(nil :: CurrentlyDragging?)\n\n-- Now we need a component to encapsulate all of our dragging behaviour, such\n-- as moving our UI between different parents, placing it at the mouse cursor,\n-- managing sizing, and so on.\n\nexport type DraggableProps = {\n    -- This should uniquely identify the draggable item apart from all other\n    -- draggable items. This is constant and so shouldn't be a state object.\n    ID: string,\n    -- It doesn't make sense for a draggable item to have a constant parent. You\n    -- wouldn't be able to drop it anywhere else, so we enforce that Parent is a\n    -- state object for our own convenience.\n    Parent: StateObject&lt;Instance?&gt;,\n    -- When an item is being dragged, it needs to appear above all other UI. We\n    -- will create an overlay frame that fills the screen to achieve this.\n    OverlayFrame: Instance,\n    -- To start a drag, we'll need to know where the top-left corner of the item\n    -- is, so we can calculate `currentlyDragging.offset`. We'll allow the\n    -- calling code to pass through a Value object to [Out \"AbsolutePosition\"].\n    OutAbsolutePosition: Value&lt;Vector2?&gt;?,\n\n    Name: CanBeState&lt;string&gt;?,\n    LayoutOrder: CanBeState&lt;number&gt;?,\n    Position: CanBeState&lt;UDim2&gt;?,\n    AnchorPoint: CanBeState&lt;Vector2&gt;?,\n    Size: CanBeState&lt;UDim2&gt;?,\n    AutomaticSize: CanBeState&lt;Enum.AutomaticSize&gt;?,\n    ZIndex: CanBeState&lt;number&gt;?,\n    [Children]: Child\n}\n\nlocal function Draggable(props: DraggableProps): Child\n    -- If we need something to be cleaned up when our item is destroyed, we can\n    -- add it to this array. It'll be passed to `[Cleanup]` later.\n    local cleanupTasks = {}\n\n    -- This acts like `currentlyDragging`, but filters out anything without a\n    -- matching ID, so it'll only exist when this specific item is dragged.\n    local thisDragging = Computed(function()\n        local dragInfo = currentlyDragging:get()\n        return if dragInfo ~= nil and dragInfo.id == props.ID then dragInfo else nil\n    end)\n\n    -- Our item controls its own parent - one of the few times you'll see this\n    -- done in Weave. This means we don't have to destroy and re-build the item\n    -- when it moves to a new location.\n    local itemParent = Computed(function()\n        return if thisDragging:get() ~= nil then props.OverlayFrame else props.Parent:get()\n    end, Weave.doNothing)\n\n    -- If we move a scaled UI into the `overlayBox`, by default it will stretch\n    -- to the screen size. Ideally we want it to preserve its current size while\n    -- it's being dragged, so we need to track the parent's size and calculate\n    -- the item size ourselves.\n\n    -- To start with, we'll store the parent's absolute size. This takes a bit\n    -- of legwork to get right, and we need to remember the UI might not have a\n    -- parent which we can measure the size of - we'll represent that as `nil`.\n    -- Feel free to extract this into a separate function if you want to.\n    local parentSize = Value(nil)\n    do\n        -- We'll call this whenever the parent's AbsoluteSize changes, or when\n        -- the parent changes (because different parents might have different\n        -- absolute sizes, if any)\n        local function recalculateParentSize()\n            -- We're not in a Computed, so we want to pass `false` to `:get()`\n            -- to avoid adding dependencies.\n            local parent = props.Parent:get(false)\n            local parentHasSize = parent ~= nil and parent:IsA(\"GuiObject\")\n            parentSize:set(if parentHasSize then parent.AbsoluteSize else nil)\n        end\n\n        -- We don't just need to connect to the AbsoluteSize changed event of\n        -- the parent we have *right now*! If the parent changes, we need to\n        -- disconnect the old event and re-connect on the new parent, which we\n        -- do here.\n        local parentSizeConn = nil\n        local function rebindToParentSize()\n            if parentSizeConn ~= nil then\n                parentSizeConn:Disconnect()\n                parentSizeConn = nil\n            end\n            local parent = props.Parent:get(false)\n            local parentHasSize = parent ~= nil and parent:IsA(\"GuiObject\")\n            if parentHasSize then\n                parentSizeConn = parent:GetPropertyChangedSignal(\"AbsoluteSize\"):Connect(recalculateParentSize)\n            end\n            recalculateParentSize()\n        end\n        rebindToParentSize()\n        local disconnect = Observer(props.Parent):onChange(rebindToParentSize)\n\n        -- When the item gets destroyed, we need to disconnect that observer and\n        -- our AbsoluteSize change event (if any is active right now)\n        table.insert(cleanupTasks, function()\n            disconnect()\n            if parentSizeConn ~= nil then\n                parentSizeConn:Disconnect()\n                parentSizeConn = nil\n            end\n        end)\n    end\n\n    -- Now that we have a reliable parent size, we can calculate the item's size\n    -- without worrying about all of those event connections.\n    if props.Size == nil then\n        props.Size = Value(UDim2.fromOffset(0, 0))\n    elseif typeof(props.Size) == \"UDim2\" then\n        props.Size = Value(props.Size)\n    end\n    local itemSize = Computed(function()\n        local udim2 = props.Size:get()\n        local scaleSize = parentSize:get() or Vector2.zero -- might be nil!\n        return UDim2.fromOffset(\n            udim2.X.Scale * scaleSize.X + udim2.X.Offset,\n            udim2.Y.Scale * scaleSize.Y + udim2.Y.Offset\n        )\n    end)\n\n    -- Similarly, we'll need to override the item's position while it's being\n    -- dragged. Happily, this is simpler to do :)\n    if props.Position == nil then\n        props.Position = Value(UDim2.fromOffset(0, 0))\n    elseif typeof(props.Position) == \"UDim2\" then\n        props.Position = Value(props.Position)\n    end\n    local itemPosition = Computed(function()\n        local dragInfo = thisDragging:get()\n        if dragInfo == nil then\n            return props.Position:get()\n        else\n            -- `dragInfo.offset` stores the distance from the top-left corner\n            -- of the item to the mouse position. Subtracting the offset from\n            -- the mouse position therefore gives us the item's position.\n            local position = mousePos:get() - dragInfo.offset\n            return UDim2.fromOffset(position.X, position.Y)\n        end\n    end)\n\n    return New \"Frame\" {\n        Name = props.Name or \"Draggable\",\n        LayoutOrder = props.LayoutOrder,\n        AnchorPoint = props.AnchorPoint,\n        AutomaticSize = props.AutomaticSize,\n        ZIndex = props.ZIndex,\n\n        Parent = itemParent,\n        Position = itemPosition,\n        Size = itemSize,\n\n        BackgroundTransparency = 1,\n\n        [Out \"AbsolutePosition\"] = props.OutAbsolutePosition,\n\n        [Children] = props[Children]\n    }\nend\n\n-- The hard part is over! Now we just need to create some draggable items and\n-- start/stop drags in response to mouse events. We'll use a very basic example.\n\n-- Let's make some to-do items. They'll show up in two lists - one for\n-- incomplete tasks, and another for complete tasks. You'll be able to drag\n-- items between the lists to mark them as complete. The lists will be sorted\n-- alphabetically so we don't have to deal with calculating where the items\n-- should be placed when they're dropped.\n\nexport type TodoItem = {\n    id: string,\n    text: string,\n    completed: Value&lt;boolean&gt;\n}\nlocal todoItems: Value&lt;TodoItem&gt; = {\n    {\n        -- You can use HttpService to easily generate unique IDs statelessly.\n        id = HttpService:GenerateGUID(),\n        text = \"Wake up today\",\n        completed = Value(true)\n    },\n    {\n        id = HttpService:GenerateGUID(),\n        text = \"Read the Fusion docs\",\n        completed = Value(true)\n    },\n    {\n        id = HttpService:GenerateGUID(),\n        text = \"Take over the universe\",\n        completed = Value(false)\n    }\n}\nlocal function getTodoItemForID(id: string): TodoItem?\n    for _, item in todoItems do\n        if item.id == id then\n            return item\n        end\n    end\n    return nil\nend\n\n-- These represent the individual draggable to-do item entries in the lists.\n-- This is where we'll use our `Draggable` component!\nexport type TodoEntryProps = {\n    Item: TodoItem,\n    Parent: StateObject&lt;Instance?&gt;,\n    OverlayFrame: Instance,\n}\nlocal function TodoEntry(props: TodoEntryProps): Child\n    local absolutePosition = Value(nil)\n\n    -- Using our item's ID, we can figure out if we're being dragged to apply\n    -- some styling for dragged items only!\n    local isDragging = Computed(function()\n        local dragInfo = currentlyDragging:get()\n        return dragInfo ~= nil and dragInfo.id == props.Item.id\n    end)\n\n    return Draggable {\n        ID = props.Item.id,\n        Parent = props.Parent,\n        OverlayFrame = props.OverlayFrame,\n        OutAbsolutePosition = absolutePosition,\n\n        Name = props.Item.text,\n        Size = UDim2.new(1, 0, 0, 50),\n\n        [Children] = New \"TextButton\" {\n            Name = \"TodoEntry\",\n\n            Size = UDim2.fromScale(1, 1),\n            BackgroundColor3 = Computed(function()\n                if isDragging:get() then\n                    return Color3.new(1, 1, 1)\n                elseif props.Item.completed:get() then\n                    return Color3.new(0, 1, 0)\n                else\n                    return Color3.new(1, 0, 0)\n                end\n            end),\n            Text = props.Item.text,\n            TextSize = 28,\n\n            -- This is where we'll detect mouse down. When the mouse is pressed\n            -- over this item, we should pick it up.\n            [OnEvent \"MouseButton1Down\"] = function()\n                -- only start a drag if we're not already dragging\n                if currentlyDragging:get(false) == nil then\n                    local itemPos = absolutePosition:get(false) or Vector2.zero\n                    local offset = mousePos:get(false) - itemPos\n                    currentlyDragging:set({\n                        id = props.Item.id,\n                        offset = offset\n                    })\n                end\n            end\n\n            -- We're not going to detect mouse up here, because in some rare\n            -- cases the event could be dropped due to lag between the item's\n            -- position and the cursor position. We'll deal with this at a\n            -- global level instead.\n        }\n    }\nend\n\n-- Now we should construct our two task lists for housing our to-do entries.\n-- Notice that they don't manage the entries themselves! The entries don't\n-- belong to these lists after all, so that'd be nonsense :)\n\n-- When we release our mouse, we need to know where to drop any dragged item we\n-- have. This will tell us if we're hovering over either list.\nlocal dropAction = Value(nil)\n\nlocal incompleteList = New \"ScrollingFrame\" {\n    Name = \"IncompleteTasks\",\n    Position = UDim2.fromScale(0.1, 0.1),\n    Size = UDim2.fromScale(0.35, 0.9),\n\n    BackgroundTransparency = 0.75,\n    BackgroundColor3 = Color3.new(1, 0, 0),\n\n    [OnEvent \"MouseEnter\"] = function()\n        dropAction:set(\"incomplete\")\n    end,\n\n    [OnEvent \"MouseLeave\"] = function()\n        if dropAction:get(false) == \"incomplete\" then\n            dropAction:set(nil) -- only clear this if it's not overwritten yet\n        end\n    end,\n\n    [Children] = {\n        New \"UIListLayout\" {\n            SortOrder = \"Name\",\n            Padding = UDim.new(0, 5)\n        }\n    }\n}\n\nlocal completedList = New \"ScrollingFrame\" {\n    Name = \"CompletedTasks\",\n    Position = UDim2.fromScale(0.55, 0.1),\n    Size = UDim2.fromScale(0.35, 0.9),\n\n    BackgroundTransparency = 0.75,\n    BackgroundColor3 = Color3.new(0, 1, 0),\n\n    [OnEvent \"MouseEnter\"] = function()\n        dropAction:set(\"completed\")\n    end,\n\n    [OnEvent \"MouseLeave\"] = function()\n        if dropAction:get(false) == \"completed\" then\n            dropAction:set(nil) -- only clear this if it's not overwritten yet\n        end\n    end,\n\n    [Children] = {\n        New \"UIListLayout\" {\n            SortOrder = \"Name\",\n            Padding = UDim.new(0, 5)\n        }\n    }\n}\n\n-- Now we can write a mouse up handler to drop our items.\n\nlocal mouseUpConn = UserInputService.InputEnded:Connect(function(inputObject)\n    if inputObject.UserInputType ~= Enum.UserInputType.MouseButton1 then\n        return\n    end\n    local dragInfo = currentlyDragging:get(false)\n    if dragInfo == nil then\n        return\n    end\n    local item = getTodoItemForID(dragInfo.id)\n    local action = dropAction:get(false)\n    if item ~= nil then\n        if action == \"incomplete\" then\n            item.completed:set(false)\n        elseif action == \"completed\" then\n            item.completed:set(true)\n        end\n    end\n    currentlyDragging:set(nil)\nend)\n\n-- We'll need to construct an overlay frame for our items to live in while they\n-- get dragged around.\n\nlocal overlayFrame = New \"Frame\" {\n    Size = UDim2.fromScale(1, 1),\n    ZIndex = 10,\n    BackgroundTransparency = 1\n}\n\n-- Let's construct the items themselves! Because we're constructing them at the\n-- global level like this, they're only created and destroyed when they're added\n-- and removed from the list.\n\nlocal allEntries = ForValues(todoItems, function(item)\n    return TodoEntry {\n        Item = item,\n        Parent = Computed(function()\n            return if item.completed:get() then completedList else incompleteList\n        end, Weave.doNothing),\n        OverlayFrame = overlayFrame\n    }\nend, Weave.cleanup)\n\n-- Finally, construct the whole UI :)\n\nlocal ui = New \"ScreenGui\" {\n    Parent = game:GetService(\"Players\").LocalPlayer.PlayerGui,\n\n    [Cleanup] = {\n        mousePosConn,\n        mouseUpConn\n    },\n\n    [Children] = {\n        overlayFrame,\n        incompleteList,\n        completedList\n\n        -- We don't have to pass `allEntries` in here - they manage their own\n        -- parenting thanks to `Draggable` :)\n    }\n}\n</code></pre>"},{"location":"examples/cookbook/fetch-data-from-server/","title":"Fetch data from server","text":"<pre><code>-- [Fusion imports omitted for clarity]\n\n-- This code assumes that there is a RemoteFunction at this location, which\n-- accepts a user ID and will return a string with that user's bio text.\n-- The server implementation is not shown here.\nlocal FetchUserBio = game:GetService(\"ReplicatedStorage\").FetchUserBio\n\n-- Creating a Value object to store the user ID we're currently looking at\nlocal currentUserID = Value(1670764)\n\n-- If we could instantly calculate the user's bio text, we could use a Computed\n-- here. However, fetching data from the server takes time, which means we can't\n-- use Computed without introducing serious consistency errors into our program.\n\n-- Instead, we fall back to using an observer to manually manage our own value:\nlocal currentUserBio = Value(nil)\n-- Using a scope to hide our management code from the rest of the script:\ndo\n    local lastFetchTime = nil\n    local function fetch()\n        local fetchTime = os.clock()\n        lastFetchTime = fetchTime\n        currentUserBio:set(nil) -- set to a default value to indicate loading\n        task.spawn(function()\n            local bio = FetchUserBio:InvokeServer(currentUserID:get(false))\n            -- If these two are not equal, then that means another fetch was\n            -- started while we were waiting for the server to return a value.\n            -- In that case, the more recent call will be more up-to-date, so we\n            -- shouldn't overwrite it. This adds a nice layer of reassurance,\n            -- but if your value doesn't change often, this might be optional.\n            if lastFetchTime == fetchTime then\n                currentUserBio:set(bio)\n            end\n        end)\n    end\n\n    fetch() -- get the bio for the initial user ID\n    -- when the user ID changes, reload the bio\n    local disconnect = Observer(currentUserID):onChange(fetch)\n\n    -- Don't forget to call `disconnect` when you're done with `currentUserBio`.\n    -- That's not included in this code snippet, but it's important if you want\n    -- to avoid leaking memory.\nend\n\n-- Now, you can use `currentUserBio` just like any other state object! Note that\n-- `nil` is used to represent a bio that hasn't loaded yet, so you'll want to\n-- handle that case before passing it into any code that expects a solid value.\n\nlocal bioLabel = New \"TextLabel\" {\n    Text = Computed(function()\n        return currentUserBio:get() or \"Loading user bio...\"\n    end)\n}\n</code></pre>"},{"location":"examples/cookbook/light-and-dark-theme/","title":"Light and dark theme","text":"<pre><code>-- [Fusion imports omitted for clarity]\n\n-- Defining some theme colours. Something to note; I'm intentionally putting the\n-- actual colour names as the topmost keys here, and putting `light` and `dark`\n-- keys inside the colours. If you did it the other way around, then there's no\n-- single source of truth for what colour names are available, and it's hard to\n-- keep in sync. If a theme doesn't have a colour, it's better to explicitly not\n-- specify it under the colour name.\n\nlocal THEME_COLOURS = {\n    background = {\n        light = Color3.fromHex(\"FFFFFF\"),\n        dark = Color3.fromHex(\"2D2D2D\")\n    },\n    text = {\n        light = Color3.fromHex(\"2D2D2D\"),\n        dark = Color3.fromHex(\"FFFFFF\")\n    },\n    -- [etc, for all the colours you'd want]\n}\n\n-- This will control which colours we're using at the moment. You could expose\n-- this to the rest of your code directly, or calculate it using a Computed.\nlocal currentTheme = Value(\"light\")\n\n-- Now we'll create a Computed for every theme colour, which will pick a colour\n-- from `THEME_COLS` based on our `currentTheme`.\nlocal currentColours = {}\nfor colourName, colourOptions in THEME_COLOURS do\n    currentColours[colourName] = Computed(function()\n        return colourOptions[currentTheme:get()]\n    end)\nend\n\n-- Now you can expose `colourOptions` to the rest of your code, preferably under\n-- a convenient name :)\n\nlocal text = New \"TextLabel\" {\n    TextColor3 = currentColours.text\n}\n</code></pre>"},{"location":"examples/cookbook/loading-spinner/","title":"Loading spinner","text":"<pre><code>local RunService = game:GetService(\"RunService\")\n-- [Fusion imports omitted for clarity]\n\n-- Loading spinners generally don't use transition-based animations like tweens.\n-- Instead, they animate continuously and independently, so we'll need to set up\n-- our own animation clock that will drive the animation.\n-- We can set up one clock and use it everywhere.\nlocal timer = Value(os.clock())\nlocal timerConn = RunService.RenderStepped:Connect(function()\n    -- Remember to disconnect this event when you're done using it!\n    timer:set(os.clock())\nend)\n\n-- Our loading spinner will consist of an image which rotates around. You could\n-- do something more complex or intricate for spice, but in the interest of\n-- providing a simple starting point, let's keep it simple.\nlocal spinner = New \"ImageLabel\" {\n    Position = UDim2.fromScale(0.5, 0.5),\n    AnchorPoint = Vector2.new(0.5, 0.5),\n    Size = UDim2.fromOffset(50, 50),\n\n    BackgroundTransparency = 1,\n    Image = \"rbxassetid://your-loading-spinner-image\", -- replace this!\n\n    -- As the timer runs, this will automatically update and rotate our image.\n    Rotation = Computed(function()\n        local time = timer:get()\n        local angle = time * 180 -- Spin at a rate of 180 degrees per second\n        angle %= 360 -- Don't need to go beyond 360 degrees; wrap instead\n        return angle\n    end),\n\n    -- If your `timer` is only used by this one loading spinner, you can clean\n    -- up the `timerConn` here. If you're re-using one timer for all of your\n    -- spinners, you don't need to do this here.\n    [Cleanup] = timerConn\n}\n</code></pre>"},{"location":"examples/cookbook/player-list/","title":"Player list","text":"<pre><code>-- [Fusion imports omitted for clarity]\n\ntype Set&lt;T&gt; = {[T]: true}\n\n-- Defining a component for each row of the player list.\n-- Each row represents a player currently logged into the server.\n-- We set the `Name` to the player's name so the rows can be sorted by name.\n\ntype PlayerListRowProps = {\n    Player: Player\n}\n\nlocal function PlayerListRow(props: PlayerListRowProps)\n    return New \"TextLabel\" {\n        Name = props.Player.DisplayName,\n\n        Size = UDim2.new(1, 0, 0, 25),\n        BackgroundTransparency = 1,\n\n        Text = props.Player.DisplayName,\n        TextColor3 = Color3.new(1, 1, 1),\n        Font = Enum.Font.GothamMedium,\n        FontSize = 16,\n        TextXAlignment = \"Right\",\n        TextTruncate = \"AtEnd\",\n\n        [Children] = New \"UIPadding\" {\n            PaddingLeft = UDim.new(0, 10),\n            PaddingRight = UDim.new(0, 10)\n        }\n    }\nend\n\n-- Defining a component for the entire player list.\n-- It should take in a set of all logged-in players, and it should be a state\n-- object so the set of players can change as players join and leave.\n\ntype PlayerListProps = {\n    PlayerSet: Fusion.StateObject&lt;Set&lt;Player&gt;&gt;\n}\n\nlocal function PlayerList(props: PlayerListProps)\n    return New \"Frame\" {\n        Name = \"PlayerList\",\n\n        Position = UDim2.fromScale(1, 0),\n        AnchorPoint = Vector2.new(1, 0),\n        Size = UDim2.fromOffset(300, 0),\n        AutomaticSize = \"Y\",\n\n        BackgroundTransparency = 0.5,\n        BackgroundColor3 = Color3.new(0, 0, 0),\n\n        [Children] = {\n            New \"UICorner\" {},\n            New \"UIListLayout\" {\n                SortOrder = \"Name\",\n                FillDirection = \"Vertical\"\n            },\n\n            ForPairs(props.PlayerSet, function(player, _)\n                return player, PlayerListRow {\n                    Player = player\n                }\n            end, Fusion.cleanup)\n        }\n    }\nend\n\n-- To create the PlayerList component, first we need a state object that stores\n-- the set of logged-in players, and updates as players join and leave.\n\nlocal Players = game:GetService(\"Players\")\n\nlocal playerSet = Value()\nlocal function updatePlayerSet()\n    local newPlayerSet = {}\n    for _, player in Players:GetPlayers() do\n        newPlayerSet[player] = true\n    end\n    playerSet:set(newPlayerSet)\nend\nlocal playerConnections = {\n    Players.PlayerAdded:Connect(updatePlayerSet),\n    Players.PlayerRemoving:Connect(updatePlayerSet)\n}\nupdatePlayerSet()\n\n-- Now, we can create the component and pass in `playerSet`.\n-- Don't forget to clean up your connections when your UI is destroyed; to do\n-- that, we're using the `[Cleanup]` key to clean up `playerConnections` later.\n\nlocal gui = New \"ScreenGui\" {\n    Name = \"PlayerListGui\",\n    Parent = Players.LocalPlayer:FindFirstChildOfClass(\"PlayerGui\"),\n\n    [Cleanup] = playerConnections,\n\n    [Children] = PlayerList {\n        PlayerSet = playerSet\n    }\n}\n</code></pre>"},{"location":"extras/","title":"Extras","text":"<p>Welcome to the Extras section! Here, you can find guidelines and assets for Fusion branding, download backgrounds and wallpapers for your devices, and more!</p>"},{"location":"extras/#commonly-used","title":"Commonly Used","text":"<ul> <li>Backgrounds</li> <li>Brand Guidelines</li> </ul>"},{"location":"extras/backgrounds/","title":"Backgrounds","text":"<p>All backgrounds are PNG format, and have been optimised for these resolutions:</p> <ul> <li>Ultrawide (7680 x 1440)</li> <li>Widescreen (2560 x 1440)</li> <li>3:2 (2256 x 1504)</li> <li>Mobile (1125 x 2436)</li> </ul> <p>These backgrounds are intended for personal use only! These backgrounds are, and remain, the copyright of Elttob. You may not use these, commercially or otherwise, without explicit written consent.</p>"},{"location":"extras/backgrounds/#isosceles","title":"Isosceles","text":"<p>A pattern of isosceles triangles distributed along the bottom, with the Fusion gradient. Background is hex colour #1D1D1F, and so might not be ideal for OLED screens.</p> <p></p> <ul> <li>Ultrawide</li> <li>Widescreen</li> <li>3:2</li> <li>Mobile</li> </ul>"},{"location":"extras/backgrounds/#extrusion","title":"Extrusion","text":"<p>A Fusion logo, with extruded fill lines coming out of the logo. Background is hex colour #0D0D0F, and so might not be ideal for OLED screens.</p> <p></p> <ul> <li>Ultrawide</li> <li>Widescreen</li> <li>3:2</li> <li>Mobile</li> </ul>"},{"location":"extras/backgrounds/#construction","title":"Construction","text":"<p>The Fusion logo, with construction lines shown and other geometric patterns. Background is 100% black, ideal for OLED screens.</p> <p></p> <ul> <li>Ultrawide</li> <li>Widescreen</li> <li>3:2</li> <li>Mobile</li> </ul>"},{"location":"extras/backgrounds/#glow","title":"Glow","text":"<p>A centred Fusion logo emitting light on a dark background. Background is 100% black, ideal for OLED screens.</p> <p></p> <ul> <li>Ultrawide</li> <li>Widescreen</li> <li>3:2</li> <li>Mobile</li> </ul>"},{"location":"extras/backgrounds/#glow-alternate","title":"Glow (Alternate)","text":"<p>A centred Fusion logo emitting light on a dark background. Uses an alternate design of the logo, which is now used for livestreams. Background is 100% black, ideal for OLED screens.</p> <p></p> <ul> <li>Ultrawide</li> <li>Widescreen</li> <li>3:2</li> <li>Mobile</li> </ul>"},{"location":"extras/brand-guidelines/","title":"Brand guidelines","text":"<p>The Fusion branding is designed to be simplistic, modern, easy to recognise and distinctive.</p>"},{"location":"extras/brand-guidelines/#colours","title":"Colours","text":""},{"location":"extras/brand-guidelines/#primaries","title":"Primaries","text":"<p>These colours are used in the Fusion logo and most illustrations. They might not be suitable for text or all backgrounds.</p> <p> </p>"},{"location":"extras/brand-guidelines/#fusiondoc-greys","title":"FusionDoc greys","text":"<p>These colours are used by the FusionDoc theme on this website for all grey tones used on pages.</p> <p> </p>"},{"location":"extras/brand-guidelines/#fusiondoc-accents","title":"FusionDoc accents","text":"<p>These colours are used by the FusionDoc theme on this website for accent colours on links and interactive elements.</p> <p> </p>"},{"location":"extras/brand-guidelines/#best-practices","title":"Best Practices","text":"<p>We would love you to use the Fusion branding in your own work, but please be mindful that you use it appropriately. If you're not sure, feel free to reach out over Discord or Twitter - it's always better to ask first to be secure!</p> <p>These aren't hard and fast rules, and we can't and don't want to police how people use our stuff. Instead, these are provided as best practices to follow. We'll add any common examples or questions to this list over time.</p>"},{"location":"extras/brand-guidelines/#brand-confusion","title":"Brand Confusion","text":"<p>Fusion's logo and name are designed to represent Fusion's official projects. Please don't use them to represent things that are not Fusion; for example, if you build your own UI library, it's better to design a new logo.</p> <p>In general, prefer to keep some distance between your project branding and Fusion's branding, enough distance that people don't get confused about who makes what, or whether a project is officially supported or not.</p> <p>It's a good litmus test to imagine a first-time user who knows nothing about Fusion, and how they will perceive your project.</p> <p>Don't do this</p> <p> </p> <pre><code>In this example, someone made their own UI library and named it Fusion 2.\nNote that this is an extreme example for demonstration purposes - most\nviolations of this principle are probably more subtle.\n\nThis is bad because people might mistakenly think the official Fusion\nproject approves or provides support for this unrelated project, which would\ncause many headaches and is dishonest about the relationship between the\ntwo libraries. Plus, in this example, we reserve the right to update Fusion\nto version 2 at any time, which would immediately cause a naming conflict.\n</code></pre> <p>Instead, do this</p> <p> </p> <pre><code>This logo makes it more clear that the project is not a port of, update to\nor bindings for the Fusion library. Instead, it's a completely distinct\nproject which only takes inspiration from Fusion, but is otherwise unrelated.\n\nIt's okay for the logo to remind people of Fusion's design. Remember - you\ndon't have to be completely original, just distinct enough that it isn't\nconfusing for people.\n</code></pre> <p>Acceptable, but be careful</p> <p> </p> <pre><code>Here, this plugin is using the Fusion logo to represent a 'Convert to\nFusion' action. This is fine, because users will understand the Fusion logo\nrepresents the thing being converted to.\n\nHowever, be careful, as free-standing uses of the Fusion icon like this can\neasily become confusing. Make sure people understand the logo represents\nFusion, and not the plugin, so confusion between the two is minimised.\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#roblox-studio","title":"Roblox Studio","text":"<p>Download the latest <code>Weave.rbxm</code> from GitHub</p> <p></p> <p>Right-click on <code>ReplicatedStorage</code>, and select 'Insert from File...':</p> <p></p> <p>Select the <code>Weave.rbxm</code> file you just downloaded.</p> <p>You should see the module script appear in <code>ReplicatedStorage</code> - you're ready to go!</p>"},{"location":"installation/#your-first-script","title":"Your First Script","text":"<p>To use Weave:</p> <ol> <li>Create a <code>Script</code> or <code>LocalScript</code></li> <li>Paste the following code in:</li> </ol> <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal Weave = require(ReplicatedStorage.Weave)\n</code></pre> <p>If there are no errors, everything was set up correctly!</p> Still didn't work? (click to expand) <p>Weave is not a valid member of ReplicatedStorage \"ReplicatedStorage\" `</p> <p>If you're seeing this error, then your script can't find Weave.</p> <p>This code assumes you've installed Weave into <code>ReplicatedStorage</code>. If you've installed Weave elsewhere, you'll need to tweak the <code>require()</code> on line 2 to point to the correct location.</p> <p>If line 2 looks like it points to the correct location, refer back to the previous section and double-check you've set everything up properly. Make sure you have a <code>ModuleScript</code> inside <code>ReplicatedStorage</code> called \"Weave\".</p>"},{"location":"installation/#wally-advanced","title":"Wally (advanced)","text":"<p>Coming Soon</p>"},{"location":"tutorials/","title":"Why Weave?","text":"<p>Imagine the state of your game as individual pieces of data.</p> <p></p> Screenshot: Pet Simulator 99 <p>When variables change, you want your game to reflect those changes.</p> <p>Unfortunately, there's no way to listen for those changes in Luau.</p> <p>You may try something like this:</p> <pre><code>local Hatch10Eggs = 0\nlocal isQuestComplete = false\n\nlocal function updateQuestUI()\n    PlayerGui.Quests.FirstQuest.CountText.Text = Hatch10Eggs\nend\n\nlocal function updateQuestComplete()\n    isQuestComplete = Hatch10Eggs &gt;= 10\nend\n\nlocal function setEggCount(newEggCount)\n    Hatch10Eggs = newEggCount\n    -- you need to send out updates to every piece of code using `eggCount` here\n    updateQuestUI()\n    updateQuestComplete()\n    updateEggCountToServer()\nend\n</code></pre> <p>But often gets messy.</p> <ul> <li>How do we share these updates across scripts?</li> <li>What if there's another piece of code using <code>Hatch10Eggs</code> that we've forgotten to update here?</li> </ul>"},{"location":"tutorials/#building-better-variables","title":"Building Better Variables","text":"<p>What if we could just change value and it updates everywhere automatically, like magic.</p> <p>That's exactly what Weave does.</p> <pre><code>local QuestData = {\n    Hatch10Eggs = Value.new(0),\n    Hatch15Eggs = Value.new(0),\n}\n</code></pre> <pre><code>-- Update a UI TextLabel\nAttach(CountText) {\n    Text = QuestData.Hatch10Eggs\n}\n</code></pre> <pre><code>-- Update a quest complete boolean\nlocal isQuestComplete = Computed.new(function()\n    return QuestData.Hatch10Eggs:get() &gt;= 10\nend)\n</code></pre> <p>Store state in a <code>Value</code> change the object's value using <code>:set()</code>.</p> <p>Then, when it changes, it will update everything that references it.</p> <p>Hence the Weave motto, set it and forget it</p>"},{"location":"tutorials/animation/springs/","title":"Springs","text":"<p>Springs follow the value of other state objects using a physical spring simulation. This can be used for 'springy' effects, or for smoothing out movement naturally without abrupt changes in direction.</p>"},{"location":"tutorials/animation/springs/#usage","title":"Usage","text":"<p>To use <code>Spring</code> in your code, you first need to import it from the Fusion module, so that you can refer to it by name:</p> <pre><code>local Weave = require(ReplicatedStorage.Weave)\nlocal Spring = Weave.Spring\n</code></pre> <p>To create a new spring object, call the <code>Spring</code> function and pass it a state object to move towards:</p> <pre><code>local goal = Value.new(0)\nlocal animated = Spring(target)\n</code></pre> <p>The spring will smoothly follow the 'goal' state object over time. As with other state objects, you can <code>:get()</code> its value at any time:</p> <pre><code>print(animated:get()) --&gt; 0.26425...\n</code></pre> <p>To configure how the spring moves, you can provide a speed and damping ratio to use. Both are optional, and both can be state objects if desired:</p> <pre><code>local goal = Value.new(0)\nlocal speed = 25\nlocal damping = Value.new(0.5)\nlocal animated = Spring(target, speed, damping)\n</code></pre> <p>You can use many different kinds of values with springs, not just numbers. Vectors, CFrames, Color3s, UDim2s and other number-based types are supported; each number inside the type is animated individually.</p> <pre><code>local goalPosition = Value.new(UDim2.new(0.5, 0, 0, 0))\nlocal animated = Spring(target, 25, 0.5)\n</code></pre>"},{"location":"tutorials/animation/springs/#damping-ratio","title":"Damping Ratio","text":"<p>The damping ratio (a.k.a damping) of the spring changes the friction in the physics simulation. Lower values allow the spring to move freely and oscillate up and down, while higher values restrict movement.</p>"},{"location":"tutorials/animation/springs/#zero-damping","title":"Zero damping","text":"<p>Zero damping means no friction is applied, so the spring will oscillate forever without losing energy. This is generally not useful.</p>"},{"location":"tutorials/animation/springs/#underdamping","title":"Underdamping","text":"<p>A damping between 0 and 1 means some friction is applied. The spring will still oscillate, but it will lose energy and eventually settle at the goal.</p>"},{"location":"tutorials/animation/springs/#critical-damping","title":"Critical damping","text":"<p>A damping of exactly 1 means just enough friction is applied to stop the spring from oscillating. It reaches its goal as quickly as possible without going past.</p> <p>This is also commonly known as critical damping.</p>"},{"location":"tutorials/animation/springs/#overdamping","title":"Overdamping","text":"<p>A damping above 1 applies excessive friction to the spring. The spring behaves like it's moving through honey, glue or some other viscous fluid.</p> <p>Overdamping reduces the effect of velocity changes, and makes movement more rigid.</p>"},{"location":"tutorials/animation/springs/#speed","title":"Speed","text":"<p>The speed of the spring scales how much time it takes for the spring to move. Doubling the speed makes it move twice as fast; halving the speed makes it move twice as slow.</p> <p> </p>"},{"location":"tutorials/animation/springs/#interruption","title":"Interruption","text":"<p>Springs do not share the same interruption problems as tweens. When the goal changes, springs are guaranteed to preserve both position and velocity, reducing jank:</p> <p> </p> <p>This also means springs are suitable for following rapidly changing values:</p> <p> </p>"},{"location":"tutorials/animation/tweens/","title":"Tweens","text":"<p>Tweens follow the value of other state objects using a pre-made animation curve. This can be used for basic, predictable animations.</p>"},{"location":"tutorials/animation/tweens/#usage","title":"Usage","text":"<p>To use <code>Tween</code> in your code, you first need to import it from the Fusion module, so that you can refer to it by name:</p> <pre><code>local Weave = require(ReplicatedStorage.Weave)\nlocal Tween = Weave.Tween\n</code></pre> <p>To create a new tween object, call the <code>Tween</code> function and pass it a state object to move towards:</p> <pre><code>local goal = Value.new(0)\nlocal animated = Tween(target)\n</code></pre> <p>The tween will smoothly follow the 'goal' state object over time. As with other state objects, you can <code>:get()</code> its value at any time:</p> <pre><code>print(animated:get()) --&gt; 0.26425...\n</code></pre> <p>To configure how the tween moves, you can provide a TweenInfo to change the shape of the animation curve. It's optional, and it can be a state object if desired:</p> <pre><code>local goal = Value.new(0)\nlocal style = TweenInfo.new(0.5, Enum.EasingStyle.Quad)\nlocal animated = Tween(target, style)\n</code></pre> <p>You can use many different kinds of values with tweens, not just numbers. Vectors, CFrames, Color3s, UDim2s and other number-based types are supported; each number inside the type is animated individually.</p> <pre><code>local goalPosition = Value.new(UDim2.new(0.5, 0, 0, 0))\nlocal animated = Tween(target, TweenInfo.new(0.5, Enum.EasingStyle.Quad))\n</code></pre>"},{"location":"tutorials/animation/tweens/#time","title":"Time","text":"<p>The first parameter of <code>TweenInfo</code> is time. This specifies how long it should take for the value to animate to the goal, in seconds.</p> <p> </p>"},{"location":"tutorials/animation/tweens/#easing-style","title":"Easing Style","text":"<p>The second parameter of <code>TweenInfo</code> is easing style. By setting this to various <code>Enum.EasingStyle</code> values, you can select different pre-made animation curves.</p> <p> </p>"},{"location":"tutorials/animation/tweens/#easing-direction","title":"Easing Direction","text":"<p>The third parameter of <code>TweenInfo</code> is easing direction. This can be set to one of three values to control how the tween starts and stops:</p> <ul> <li><code>Enum.EasingDirection.Out</code> makes the tween animate out smoothly.</li> <li><code>Enum.EasingDirection.In</code> makes the tween animate in smoothly.</li> <li><code>Enum.EasingDirection.InOut</code> makes the tween animate in and out smoothly.</li> </ul> <p> </p>"},{"location":"tutorials/animation/tweens/#repeats","title":"Repeats","text":"<p>The fourth parameter of <code>TweenInfo</code> is repeat count. This can be used to loop the animation a number of times.</p> <p>Setting the repeat count to a negative number causes it to loop infinitely. This is not generally useful for transition animations.</p> <p> </p>"},{"location":"tutorials/animation/tweens/#reversing","title":"Reversing","text":"<p>The fifth parameter of <code>TweenInfo</code> is a reversing option. When enabled, the animation will return to the starting point.</p> <p>This is not typically useful because the animation doesn't end at the goal value, and might not end at the start value either if the animation is interrupted.</p> <p> </p>"},{"location":"tutorials/animation/tweens/#delay","title":"Delay","text":"<p>The sixth and final parameter of <code>TweenInfo</code> is delay. Increasing this delay adds empty space before the beginning of the animation curve.</p> <p>It's important to note this is not the same as a true delay. This option does not delay the input signal - it only makes the tween animation longer.</p> <p> </p>"},{"location":"tutorials/animation/tweens/#interruption","title":"Interruption","text":"<p>Because tweens are built from pre-made, fixed animation curves, you should avoid interrupting those animation curves before they're finished.</p> <p>Interrupting a tween halfway through leads to abrupt changes in velocity, which can cause your animation to feel janky:</p> <p> </p> <p>Tweens also can't track constantly changing targets very well. That's because the tween is always getting interrupted as it gets started, so it never has time to play out much of its animation.</p> <p> </p> <p>These issues arise because tweens don't 'remember' their previous velocity when they start animating towards a new goal. If you need velocity to be remembered, it's a much better idea to use springs, which can preserve their momentum.</p>"},{"location":"tutorials/components/callbacks/","title":"Callbacks","text":"<p>Normally, components are controlled by the code creating them. This is called top-down control, and is the primary flow of control in Fusion.</p> <p> </p> <p>However, sometimes components need to talk back to their controlling code, for example to report when button clicks occur.</p>"},{"location":"tutorials/components/callbacks/#in-luau","title":"In Luau","text":"<p>Callbacks are functions which you pass into other functions. They're part of normal Luau code.</p> <pre><code>workspace.ChildAdded:Connect(function()\n    -- this function is a callback!\nend)\n</code></pre> <p>They're useful because they allow the function to 'call back' into your code, so your code can do something in response:</p> <pre><code>local function printMessage()\n    print(\"Hello, world!\")\nend\n\n-- Here, we're passing `printMessage` as a callback\n-- `task.delay` will call it after 5 seconds\ntask.delay(5, printMessage)\n</code></pre> <p>If your function accepts a callback, then you can call it like any other function. Luau will execute the function, then return to your code.</p> <p>In this example, the <code>fiveTimes</code> function calls a callback five times:</p> Script codeOutput <pre><code>local function fiveTimes(callback)\n    for x=1, 5 do\n        callback(x)\n    end\nend\n\nfiveTimes(function(num)\n    print(\"The number is\", num)\nend)\n</code></pre> <pre><code>The number is 1\nThe number is 2\nThe number is 3\nThe number is 4\nThe number is 5\n</code></pre>"},{"location":"tutorials/components/callbacks/#in-fusion","title":"In Fusion","text":"<p>Components can use callbacks the same way. Consider this button component; when the button is clicked, the button needs to run some external code:</p> <pre><code>local function Button(props)\n    return New \"TextButton\" {\n        BackgroundColor3 = Color3.new(0.25, 0.5, 1),\n        Position = props.Position,\n        Size = props.Size,\n\n        Text = props.Text,\n        TextColor3 = Color3.new(1, 1, 1),\n\n        [OnEvent \"Activated\"] = -- ???\n    }\nend\n</code></pre> <p>It can ask the controlling code to provide a callback in <code>props</code>, called OnClick:</p> <pre><code>local button = Button {\n    Text = \"Hello, world!\",\n    OnClick = function()\n        print(\"The button was clicked\")\n    end\n}\n</code></pre> <p>Assuming that callback is passed in, the callback can be passed directly into <code>[OnEvent]</code>, because <code>[OnEvent]</code> accepts functions:</p> <pre><code>local function Button(props)\n    return New \"TextButton\" {\n        BackgroundColor3 = Color3.new(0.25, 0.5, 1),\n        Position = props.Position,\n        Size = props.Size,\n\n        Text = props.Text,\n        TextColor3 = Color3.new(1, 1, 1),\n\n        [OnEvent \"Activated\"] = props.OnClick\n    }\nend\n</code></pre> <p>Alternatively, we can call <code>props.OnClick</code> manually, which is useful if you want to do your own processing first:</p> <pre><code>local function Button(props)\n    return New \"TextButton\" {\n        BackgroundColor3 = Color3.new(0.25, 0.5, 1),\n        Position = props.Position,\n        Size = props.Size,\n\n        Text = props.Text,\n        TextColor3 = Color3.new(1, 1, 1),\n\n        [OnEvent \"Activated\"] = function()\n            -- don't send clicks if the button is disabled\n            if not props.Disabled:get() then\n                props.OnClick()\n            end\n        end\n    }\nend\n</code></pre> <p>This is the primary way components talk to their controlling code in Fusion.</p>"},{"location":"tutorials/components/children/","title":"Children","text":"<p>Using components, you can assemble more complex instance hierarchies by combining simpler, self-contained parts. To do that, you should pay attention to how instances are passed between components.</p>"},{"location":"tutorials/components/children/#returning-children","title":"Returning Children","text":"<p>Components return a child when you call them. That means anything you return from a component should be supported by <code>[Children]</code>.</p> <p>That means you can return one (and only one):</p> <ul> <li>instance</li> <li>array of children</li> <li>or state object containing a child</li> </ul> <p>This should be familiar from parenting instances using <code>[Children]</code>. To recap:</p> <p>Allowed</p> <p>You can return one value per component. <code>Luau     -- returns *one* instance     local function Component()         return New \"Frame\" {}     end</code> <code>Luau     -- returns *one* array     local function Component()         return {             New \"Frame\" {},             New \"Frame\" {},             New \"Frame\" {}         }     end</code> <code>Luau     -- returns *one* state object     local function Component()         return ForValues({1, 2, 3}, function()             return New \"Frame\" {}         end)     end</code></p> <p>Allowed</p> <p>Inside arrays or state objects, you can mix and match different children. <code>Luau     -- mix of arrays, instances and state objects     local function Component()         return {             New \"Frame\" {},             {                 New \"Frame\" {},                 ForValues( ... )             }             ForValues( ... )         }     end</code></p> <p>Not allowed</p> <p>Don't return multiple values straight from your function. Prefer to use an array instead. <code>Luau     -- returns *multiple* instances (not surrounded by curly braces!)     local function Component()         return             New \"Frame\" {},             New \"Frame\" {},             New \"Frame\" {}     end</code> Luau does not support multiple return values consistently. They can get lost easily if you're not careful.</p>"},{"location":"tutorials/components/children/#parenting-components","title":"Parenting Components","text":"<p>Components return the same values which <code>[Children]</code> uses. That means they're directly compatible, and you can insert a component anywhere you'd normally insert an instance.</p> <p>You can pass in one component on its own...</p> <pre><code>local ui = New \"ScreenGui\" {\n    [Children] = Button {\n        Text = \"Hello, world!\"\n    }\n}\n</code></pre> <p>...you can include components as part of an array..</p> <pre><code>local ui = New \"ScreenGui\" {\n    [Children] = {\n        New \"UIListLayout\" {},\n        Button {\n            Text = \"Hello, world!\"\n        },\n        Button {\n            Text = \"Hello, again!\"\n        }\n    }\n}\n</code></pre> <p>...and you can return them from state objects, too.</p> <pre><code>local ui = New \"ScreenGui\" {\n    [Children] = {\n        New \"UIListLayout\" {},\n\n        ForValues({\"Hello\", \"world\", \"from\", \"Fusion\"}, function(text)\n            return Button {\n                Text = text\n            }\n        end)\n    }\n}\n</code></pre>"},{"location":"tutorials/components/children/#accepting-children","title":"Accepting Children","text":"<p>Some components, for example pop-ups, might contain lots of different content:</p> <p> </p> <p>Ideally, you would be able to reuse the pop-up 'container', while placing your own content inside.</p> <p> </p> <p>The simplest way to do this is to pass children through to <code>[Children]</code>. For example, if you accept a table of <code>props</code>, you can add a <code>[Children]</code> key:</p> <pre><code>local function PopUp(props)\n    return New \"Frame\" {\n        -- ... some other properties ...\n\n        -- Since `props` is a table, and `[Children]` is a key, you can use it\n        -- yourself as a key in `props`:\n        [Children] = props[Children]\n    }\nend\n</code></pre> <p>Later on, when a pop-up is created, children can now be parented into that instance:</p> <pre><code>local popUp = PopUp {\n    [Children] = {\n        Label {\n            Text = \"New item collected\"\n        },\n        ItemPreview {\n            Item = Items.BRICK\n        },\n        Button {\n            Text = \"Add to inventory\"\n        }\n    }\n}\n</code></pre> <p>You're not limited to passing it straight into <code>[Children]</code>. If you need to add other children, you can still use arrays and state objects as normal:</p> <pre><code>local function PopUp(props)\n    return New \"Frame\" {\n        -- ... some other properties ...\n\n        [Children] = {\n            -- the component provides some children here\n            New \"UICorner\" {\n                CornerRadius = UDim.new(0, 8)\n            },\n\n            -- include children from outside the component here\n            props[Children]\n        }\n    }\nend\n</code></pre>"},{"location":"tutorials/components/reusing-ui/","title":"Reusing UI","text":"<p>Up until this point, you have been creating and parenting instances directly without much organisation or code reuse. However, those two factors will become increasingly important as you start building more game-ready UIs.</p> <p>These next few pages won't introduce new features of Fusion, but instead will focus on techniques for making your UI more modular, portable and easy to maintain.</p>"},{"location":"tutorials/components/reusing-ui/#components","title":"Components","text":"<p>One of the greatest advantages of libraries like Fusion is that UI and code are the same thing. Any tool you can use on one, you can use on the other.</p> <p>To reduce repetition in your codebases, you'll often use functions to run small reusable blocks of code, sometimes with parameters you can change. You can use functions to organise your UI code, too.</p> <p>For example, consider this function, which generates a button based on some <code>props</code> the user passes in:</p> <pre><code>local function Button(props)\n    return New \"TextButton\" {\n        BackgroundColor3 = Color3.new(0, 0.25, 1),\n        Position = props.Position,\n        AnchorPoint = props.AnchorPoint,\n        Size = props.Size,\n        LayoutOrder = props.LayoutOrder,\n\n        Text = props.ButtonText,\n        TextSize = 28,\n        TextColor3 = Color3.new(1, 1, 1),\n\n        [Children] = UICorner { CornerRadius = UDim2.new(0, 8) }\n    }\nend\n</code></pre> <p>You can call this function later to generate as many buttons as you need:</p> <pre><code>-- this is just a regular Lua function call!\nlocal helloBtn = Button {\n    ButtonText = \"Hello\",\n    Size = UDim2.fromOffset(200, 50)\n}\n\nhelloBtn.Parent = Players.LocalPlayer.PlayerGui.ScreenGui\n</code></pre> <p>This is the primary way UI is reused in Fusion. These kinds of functions are common enough that they have a special name: components. Specifically, components are functions which return a child.</p> <p>In the above example, <code>Button</code> is a component, because it's a function that returns a TextButton.</p>"},{"location":"tutorials/components/reusing-ui/#modules","title":"Modules","text":"<p>It's common to save different components inside of different ModuleScripts. There's a number of advantages to this:</p> <ul> <li>it's easier to find the source code for a specific component</li> <li>it keep each script shorter and simpler</li> <li>it makes sure components are properly independent, and can't interfere</li> <li>it encourages reusing components everywhere, not just in one script</li> </ul> <p>Here's an example of how you could split up some components into modules:</p> Main scriptPopUp.luaMessage.luaButton.lua <pre><code>local PopUp = require(script.Parent.PopUp)\n\nlocal ui = New \"ScreenGui\" {\n    -- ...some properties...\n\n    [Children] = PopUp {\n        Message = \"Hello, world!\",\n        DismissText = \"Close\"\n    }\n}\n</code></pre> <pre><code>local Message = require(script.Parent.Message)\nlocal Button = require(script.Parent.Button)\n\nlocal function PopUp(props)\n    return New \"Frame\" {\n        -- ...some properties...\n\n        [Children] = {\n            Message {\n                Text = props.Message\n            }\n            Button {\n                Text = props.DismissText\n            }\n        }\n    }\nend\n\nreturn PopUp\n</code></pre> <pre><code>local function Message(props)\n    return New \"TextLabel\" {\n        AutomaticSize = \"XY\",\n        BackgroundTransparency = 1,\n\n         -- ...some properties...\n\n        Text = props.Text\n    }\nend\n\nreturn Message\n</code></pre> <pre><code>local function Button(props)\n    return New \"TextButton\" {\n        BackgroundColor3 = Color3.new(0.25, 0.5, 1),\n        AutoButtonColor = true,\n\n         -- ...some properties...\n\n        Text = props.Text\n    }\nend\n\nreturn Button\n</code></pre> <p>You can further group your modules using folders if you need more organisation.</p> <p>It might be scary at first to see a large list of modules, but because you can browse visually by names and folders, it's almost always better than having one long script.</p>"},{"location":"tutorials/components/state/","title":"State","text":"<p>Components can hold their own data privately using state objects. This can be useful, but you should be careful when adding state.</p>"},{"location":"tutorials/components/state/#creating-state-objects","title":"Creating State Objects","text":"<p>Inside a component, state objects can be created and used the same way as usual:</p> <pre><code>local HOVER_COLOUR = Color3.new(0.5, 0.75, 1)\nlocal REST_COLOUR = Color3.new(0.25, 0.5, 1)\n\nlocal function Button(props)\n    local isHovering = Value.new(false)\n\n    return New \"TextButton\" {\n        BackgroundColor3 = Computed(function()\n            return if isHovering:get() then HOVER_COLOUR else REST_COLOUR\n        end),\n\n        [OnEvent \"MouseEnter\"] = function()\n            isHovering:set(true)\n        end,\n\n        [OnEvent \"MouseLeave\"] = function()\n            isHovering:set(false)\n        end,\n\n        -- ... some properties ...\n    }\nend\n</code></pre> <p>Like regular Luau, state objects stay around as long as they're being used. Once your component is destroyed and your code no longer uses the objects, they'll be cleaned up.</p>"},{"location":"tutorials/components/state/#top-down-control","title":"Top-Down Control","text":"<p>Remember that Weave mainly works with a top-down flow of control. It's a good idea to keep that in mind when adding state to components.</p> <p>When you're making reusable components, it's more flexible if your component can be controlled externally. Components that control themselves entirely are hard to use and customise.</p> <p>Consider the example of a check box. Each check box often reflects a state object under the hood:</p> <p> </p> <p>It might seem logical to store the state object inside the check box:</p> <pre><code>local function CheckBox(props)\n    local isChecked = Value.new(false)\n\n    return New \"ImageButton\" {\n        -- ... some properties ...\n    }\nend\n</code></pre> <p>However, hiding away important state in components causes a few problems:</p> <ul> <li>to control the appearance of the check box, you're forced to change the   internal state</li> <li>clicking the check box has hard-coded behaviour, which is bad if you need to   intercept the click (e.g. to show a confirmation dialogue)</li> <li>if you already had a state object for that setting, now the check box has a   duplicate state object representing the same setting</li> </ul> <p>Therefore, it's better for the controlling code to hold the state object, and use callbacks to switch the value when the check box is clicked:</p> <pre><code>local playMusic = Value.new(true)\n\nlocal checkBox = CheckBox {\n    Text = \"Play music\",\n    IsChecked = playMusic,\n    OnClick = function()\n        playMusic:set(not playMusic:get())\n    end\n}\n</code></pre> <p>The control is always top-down here; the check box's appearance is fully controlled by the creator. The creator of the check box decides to switch the setting when the check box is clicked.</p> <p>The check box itself is an inert, visual element; it just shows a graphic and reports clicks.</p> <p>Setting up the check box this way also allows for more complex behaviour later on. Suppose we wanted to group together multiple options under a 'main' check box, so you can turn them all on/off at once.</p> <p> </p> <p>The appearance of that check box would not be controlled by a single state, but instead reflects the combination of multiple states. We can use a <code>Computed</code> for that:</p> <pre><code>local playMusic = Value.new(true)\nlocal playSFX = Value.new(false)\nlocal playNarration = Value.new(true)\n\nlocal checkBox = CheckBox {\n    Text = \"Play sounds\",\n    Appearance = Computed(function()\n        local anyChecked = playMusic:get() or playSFX:get() or playNarration:get()\n        local allChecked = playMusic:get() and playSFX:get() and playNarration:get()\n\n        if not anyChecked then\n            return \"unchecked\"\n        elseif not allChecked then\n            return \"partially-checked\"\n        else\n            return \"checked\"\n        end\n    end)\n}\n</code></pre> <p>We can then implement the 'check all'/'uncheck all' behaviour inside <code>OnClick</code>:</p> <pre><code>local playMusic = Value.new(true)\nlocal playSFX = Value.new(false)\nlocal playNarration = Value.new(true)\n\nlocal checkBox = CheckBox {\n    -- ... same properties as before ...\n    OnClick = function()\n        local allChecked = playMusic:get() and playSFX:get() and playNarration:get()\n\n        playMusic:set(not allChecked)\n        playSFX:set(not allChecked)\n        playNarration:set(not allChecked)\n    end\n}\n</code></pre> <p>By keeping the check box 'stateless', we can make it behave much more flexibly.</p>"},{"location":"tutorials/components/state/#best-practices","title":"Best Practices","text":"<p>Those examples lead us into the golden rule when adding state to components.</p> <p>Golden Rule</p> <p>It's better for reusable components to reflect program state. They should not usually contain program state.</p> <p>State objects are best suited to self-contained use cases, such as implementing hover effects, animations or responsive design. As such, you should think about whether you really need to add state to components, or whether it's better to add it higher up.</p> <p>At first, this might be difficult to do well, but with experience you'll have a better intuition for it. Remember that you can always rewrite your code if it becomes a problem!</p>"},{"location":"tutorials/fundamentals/computeds/","title":"Computed","text":"<p><code>Computed</code> values can be used to calculate new values.</p> <p>Pass in a function that does the calculation.</p> <pre><code>local userName = Value.new(\"Preston\")\n\nlocal welcomeMessage = Computed.new(function()\n    return `Welcome, {userName:get()}!`\nend)\n\nwelcomeMessage:get() --&gt; \"Welcome, Preston!\"\n</code></pre> <p><code>Computed</code> values update automatically:</p> <pre><code>userName:set(\"Jandel\")\n\nwelcomeMessage:get() --&gt; \"Welcome, Jandel!\"\n</code></pre>"},{"location":"tutorials/fundamentals/computeds/#usage","title":"Usage","text":"<p>Import <code>Weave.Computed</code> from the Weave module.</p> <pre><code>local Weave = require(ReplicatedStorage.Weave)\nlocal Computed = Weave.Computed\n</code></pre> <p><code>Computed.new</code> to make a new object.</p> <pre><code>local greeting = Value.new(\"Welcome\")\nlocal userName = Value.new(\"Preston\")\n\nlocal combinedMessage = Computed.new(function()\n    return `{greeting:get()}, {userName:get()}!`\nend)\n</code></pre> <p>You can get the computed's current value using <code>:get()</code>:</p> <pre><code>combinedMessage:get() --&gt; \"Welcome, Preston!\"\n</code></pre> <p>The <code>Computed</code> function runs again when any of its dependencies change</p> <pre><code>greeting:set(\"Hello\")\n\ncombinedMessage:get() --&gt; \"Hello, Preston!\"\n</code></pre> <pre><code>userName:set(\"Jandel\")\n\ncombinedMessage:get() --&gt; \"Hello, Jandel!\"\n</code></pre> <p>Putting it all together:</p> <pre><code>local greeting = Value.new(\"Welcome\")\nlocal userName = Value.new(\"Preston\")\n\nlocal combinedMessage = Computed.new(function()\n    return `{greeting}, {userName}!`\nend)\n\ncombinedMessage:get() --&gt; \"Welcome, Preston!\"\n\ngreeting:set(\"Hello\")\ncombinedMessage:get() --&gt; \"Hello, Preston!\"\n\nuserName:set(\"Jandel\")\ncombinedMessage:get() --&gt; \"Hello, Jandel!\"\n</code></pre>"},{"location":"tutorials/fundamentals/computeds/#changed","title":"<code>.Changed</code>","text":"<p>Just like <code>Value</code>, when <code>Computed</code> changes <code>.Changed</code> is fired.</p> <pre><code>local double = Computed.new(function()\n    return number:get() * 2\nend)\n\ndouble.Changed:Connect(onDoubleChanged)\n</code></pre> <p>Note: You can also use <code>:get()</code> to get the updated value.</p>"},{"location":"tutorials/fundamentals/computeds/#destroy","title":"<code>:Destroy()</code>","text":"<p>Call <code>:Destroy()</code> just like any Roblox <code>Instance</code></p> <pre><code>local double = Computed.new(function()\n    return number:get() * 2\nend)\n\ndouble:Destroy()\n</code></pre> <p>Values that depends on this <code>Computed</code> will no longer update.</p>"},{"location":"tutorials/fundamentals/computeds/#when-to-use-this","title":"When To Use This","text":"<p><code>Computed</code> values make it easier to calculate new state from existing state.</p> <p>Derived values show up a lot in games.</p> <p>For example, you might want to insert a number into a string to display in the UI.</p> A warning about delays in computed callbacks <p>One small caveat of computeds is that you must return the value immediately. If you need to send a request to the server or perform a long-running calculation, you shouldn't use computeds.</p> <p>The reason for this is consistency between variables. When all computeds run</p> <p>immediately (i.e. without yielding), all of your variables will behave consistently:</p> <pre><code>local numCoins = Value.new(50)\nlocal isEnoughCoins = Computed.new(function()\n    return numCoins:get() &gt; 25\nend)\n\nlocal message = Computed.new(function()\n    if isEnoughCoins:get() then\n        return numCoins:get() .. \" is enough coins.\"\n    else\n        return numCoins:get() .. \" is NOT enough coins.\"\n    end\nend)\n\nmessage:get() --&gt; 50 is enough coins.\nnumCoins:set(2)\nmessage:get() --&gt; 2 is NOT enough coins.\n</code></pre> <p>If a delay is introduced, then inconsistencies and nonsense values could quickly appear:</p> <pre><code>local numCoins = Value.new(50)\nlocal isEnoughCoins = Computed.new(function()\n    task.wait(5) -- Don't do this! This is just for the example\n    return numCoins:get() &gt; 25\nend)\n\nlocal message = Computed.new(function()\n    if isEnoughCoins:get() then\n        return `{numCoins:get()} is enough coins.`\n    else\n        return `{numCoins:get()} is NOT enough coins.`\n    end\nend)\n\nprint(message:get()) --&gt; 50 is enough coins.\nnumCoins:set(2)\nprint(message:get()) --&gt; 2 is enough coins.\n</code></pre> <p>For this reason, yielding in computed callbacks is disallowed.</p> <p>If you have to introduce a delay, for example when invoking a RemoteFunction, consider using values and connecting to the Changed event.</p> <pre><code>local numCoins = Value.new(50)\n\nlocal isEnoughCoins = Value.new(nil)\nlocal function updateIsEnoughCoins()\n    isEnoughCoins:set(nil) -- indicate that we're calculating the value\n    task.wait(5) -- this is now ok\n    isEnoughCoins:set(numCoins:get() &gt; 25)\nend\ntask.spawn(updateIsEnoughCoins)\nnumCoins.Changed:Connect(updateIsEnoughCoins)\n\nlocal message = Computed.new(function()\n    if isEnoughCoins:get() == nil then\n        return \"Loading...\"\n    elseif isEnoughCoins:get() then\n        return numCoins:get() .. \" is enough coins.\"\n    else\n        return numCoins:get() .. \" is NOT enough coins.\"\n    end\nend)\n\nprint(message:get()) --&gt; 50 is enough coins.\nnumCoins:set(2)\nprint(message:get()) --&gt; Loading...\ntask.wait(5)\nprint(message:get()) --&gt; 2 is NOT enough coins.\n</code></pre>"},{"location":"tutorials/fundamentals/destructors/","title":"Destructors","text":"<p>Destructors are functions that clean up values passed to them. Computed objects use them to clean up old values when they're no longer needed.</p> <pre><code>local function callDestroy(x)\n    x:Destroy()\nend\n\nlocal brick = Computed.new(function()\n    return Instance.new(\"Part\")\nend, callDestroy)\n</code></pre>"},{"location":"tutorials/fundamentals/destructors/#memory-management","title":"Memory Management","text":"<p>In Luau, most values clean themselves up automatically, because they're managed by the garbage collector:</p> <pre><code>-- This will create a new table in memory:\nlocal x = {\n    hello = \"world\"\n}\ntask.wait(5)\n-- The table is destroyed automatically when you stop using it.\nx = nil\n</code></pre> <p>However, not all values clean themselves up. Some common 'unmanaged' types are:</p> <ol> <li>Instances - need to be <code>:Destroy()</code>ed</li> <li>Event connections - need to be <code>:Disconnect()</code>ed</li> <li>Custom objects - might provide their own <code>:Destroy()</code> methods.</li> </ol> <p>The garbage collector doesn't manage these for you, so if you don't clean them up, they could stick around forever:</p> <pre><code>-- We're creating an event connection here.\nlocal event = workspace.Changed:Connect(function()\n    print(\"Hello!\")\nend)\n\n-- Even if we stop using the event connection in our code, it will continue to\n-- receive events. It will not be disconnected for you.\nevent = nil\n</code></pre>"},{"location":"tutorials/fundamentals/destructors/#state-objects","title":"State Objects","text":"<p>Those types of values are a problem for Computed objects. For example, if they generate fresh instances, they need to destroy those instances too:</p> <pre><code>local className = Value.new(\"Frame\")\n-- `instance` will generate a Frame at first\nlocal instance = Computed.new(function()\n    return Instance.new(className:get())\nend)\n-- This will cause it to generate a TextLabel - but we didn't destroy the Frame!\nclassName:set(\"TextLabel\")\n</code></pre> <p>This is where destructors help out. You can provide a second function, which Weave will call to destroy the values we generate:</p> <pre><code>local function callDestroy(x)\n    x:Destroy()\nend\n\nlocal instance = Computed.new(function()\n    return Instance.new(className:get())\nend, callDestroy)\n</code></pre> <p>Destructors aren't limited to typical cleanup behaviour! You can customise what happens during cleanup, or do no cleanup at all:</p> <pre><code>local function moveToServerStorage(x)\n    x.Parent = game:GetService(\"ServerStorage\")\nend\n\nlocal function doNothing(x)\n    -- intentionally left blank\nend\n</code></pre>"},{"location":"tutorials/fundamentals/destructors/#shorthand","title":"Shorthand","text":"<p>Most of the time, you'll want to either:</p> <ol> <li>destroy/disconnect/clean up the values you generate...</li> <li>...or leave them alone and do nothing.</li> </ol> <p>Weave provides default destructors for both of these situations.</p>"},{"location":"tutorials/fundamentals/destructors/#cleanup","title":"Cleanup","text":"<p><code>Weave.cleanup</code> is a function which tries to cleans up whatever you pass to it:</p> <ul> <li>given an instance, it is <code>:Destroy()</code>ed</li> <li>given an event connection, it is <code>:Disconnect()</code>ed</li> <li>given an object, any <code>:destroy()</code> or <code>:Destroy()</code> methods are run</li> <li>given a function, the function is run</li> <li>given an array, it cleans up everything inside</li> </ul> <p>You can use this when generating unmanaged values:</p> <pre><code>local instance = Computed.new(function()\n    return Instance.new(className:get())\nend, Weave.cleanup)\n</code></pre>"},{"location":"tutorials/fundamentals/destructors/#do-nothing","title":"Do Nothing","text":"<p><code>Weave.doNothing</code> is an empty function. It does nothing.</p> <p>You can use this when passing 'through' unmanaged values that you don't control. It makes it clear that your code is supposed to leave the values alone:</p> <pre><code>local instance = Computed.new(function()\n    return workspace:FindFirstChild(name:get())\nend, Weave.doNothing)\n</code></pre>"},{"location":"tutorials/fundamentals/values/","title":"Value","text":"<p>Import <code>Weave.Value</code> from the Weave module.</p> <pre><code>local Weave = require(ReplicatedStorage.Weave)\nlocal Value = Weave.Value\n</code></pre> <p>A Weave <code>Value</code> is an object that stores a Luau value.</p> <pre><code>local health = Value.new(100)\n\nhealth:get() --&gt; 100\n\nhealth:set(99)\n</code></pre>"},{"location":"tutorials/fundamentals/values/#usage","title":"Usage","text":"<p>Use <code>:get()</code> to read the value</p> <p>Use <code>:set()</code> to change it</p> <pre><code>local health = Value.new(100)\n\nhealth:get() --&gt; 100\n\nhealth:set(25)\n\nhealth:get() --&gt; 25\n</code></pre> <p><code>Value</code> can store any Luau value:</p> <pre><code>local name = Value.new(\"Bob\")\n\nlocal ammoAmount = Value.new(50)\n\nlocal sprinting = Value.new(false)\n\nlocal inventory = Value.new({ \"apple\", \"pear\" })\n\nlocal targetPart = Value.new(Instance.new(\"Part\"))\n</code></pre>"},{"location":"tutorials/fundamentals/values/#changed","title":"<code>.Changed</code>","text":"<p>When a <code>Value</code> changes, <code>.Changed</code> is fired.</p> <pre><code>local health = Value.new(100)\n\nhealth.Changed:Connect(onHealthUpdated)\n</code></pre> <p><code>.Changed</code> passes the <code>newValue</code> as the argument.</p> <pre><code>health.Changed:Connect(function(newHealth: number)\n    print(`The new health is: {newHealth}`)\nend)\n</code></pre> <p><code>.Changed</code> returns a connection you can <code>:Disconnect()</code> from</p> <pre><code>local connection = health.Changed:Connect(function()\n    print(`The new health is: {health:get()}`)\nend)\n\n-- do some stuff\n\nconnection:Disconnect()\n</code></pre> <p>Note: You can also use <code>:get()</code> inside of <code>.Changed</code>.</p>"},{"location":"tutorials/fundamentals/values/#destroy","title":"<code>:Destroy()</code>","text":"<p>Call <code>:Destroy()</code> just like any Roblox <code>Instance</code></p> <pre><code>local health = Value.new(100)\n\nhealth:Destroy()\n</code></pre> <p>Values that depends on this <code>Value</code> will no longer update.</p> <p>And <code>.Changed</code> will no longer fire.</p> <p>For advanced users: Yes, this will work with <code>Trove</code> and <code>Maid</code></p>"},{"location":"tutorials/instances/attach/","title":"Attach","text":"<p>Weave provides an <code>Attach</code> function for updating any <code>Instance</code> property.</p> <pre><code>local ammo = Value.new(36)\n</code></pre> <pre><code>Attach(ScreenGui.GunInfo.TextLabel) {\n    BackgroundColor3 = Color3.new(0, 0, 1),\n    Text = ammo,\n}\n</code></pre> <pre><code>Attach(Gun.SurfaceGui.TextLabel) {\n    BackgroundColor3 = Color3.new(1, 1, 1),\n    Text = ammo,\n}\n</code></pre> <p>Any Weave <code>Value</code> or <code>Computed</code> will update the Instance automatically.</p> <p> </p> Screenshot: GameUIDatabase (Halo Infinite)"},{"location":"tutorials/instances/attach/#explained","title":"Explained","text":"<p><code>Attach</code> may look weird, but it is valid Luau</p> <pre><code>local function someFunction(arg)\n    -- do stuff\nend\n\nsomeFunction({ Text = \"Some Text\", Color3 = Color3.new(1, 1, 1) })\n</code></pre> <p>Is the exact same as</p> <pre><code>someFunction {\n    Text = \"Some Text\",\n    Color3 = Color3.new(1, 1, 1)\n}\n</code></pre> <p>Still don't believe it? Run the code in luau.org/AttachDemo</p>"},{"location":"tutorials/instances/attach/#usage","title":"Usage","text":"<p>Import the <code>Attach</code> module from Weave:</p> <pre><code>local Weave = require(ReplicatedStorage.Weave)\nlocal Attach = Weave.Attach\n</code></pre> <p>The Attach function is called in two parts.</p> <p>Call <code>Attach</code> with the <code>Instance</code> you want to update</p> <pre><code>Attach(Frame) -- TODO: Add Properties\n</code></pre> <p>Then, define a table of properties:</p> <pre><code>Attach(Frame) {\n    Size = UDim2.new(1, 0, 1, 0),\n}\n</code></pre> <p><code>Attach</code> works on any Roblox <code>Instance</code> type and any Property</p> <pre><code>Attach(workspace.Part) {\n    BrickColor = BrickColor.Red()\n}\n\nAttach(ScreenGui.Frame) {\n    Visible = false\n}\n\nAttach(workspace.CurrentCamera) {\n    CameraType = Enum.CameraType.Scriptable\n}\n</code></pre> <p>Constant values are applied to the instance directly.</p> <pre><code>local message = Value.new(\"Loading...\")\n\nAttach(PlayerGui.Message) {\n    Text = message\n}\n\nprint(PlayerGui.Message.Text) --&gt; Loading...\n</code></pre> <p>Updates to <code>Value</code> and <code>Computed</code> values will be applied on the next frame:</p> <pre><code>message:set(\"All done!\")\n\ntask.wait() -- important: changes are applied on the next frame!\n\nprint(PlayerGui.Message.Text) --&gt; All done!\n</code></pre>"},{"location":"tutorials/instances/attach/#instance-reuse","title":"Instance Reuse","text":"<p><code>Attach</code> returns the Instance you provide, so you can re-use it:</p> <pre><code>local messageLabel = Attach(PlayerGui.Message) {\n    Text = message\n}\n\nprint(messageLabel.Text) --&gt; Loading...\n</code></pre>"},{"location":"tutorials/instances/attributevalue/","title":"Attribute Value","text":"<p>We can listen to changes to the attribute with <code>AttributeValue</code></p> <pre><code>local count = AttributeValue.new(part, \"damaged\")\n\nprint(damaged:get()) -- false\n</code></pre> <p><code>AttributeValue</code> can update from:</p> <p>Calling <code>:set()</code> on the <code>AttributeValue</code></p> <pre><code>damaged:set(true)\n\ndamaged:get() -- true\n\ntask.wait() -- Weave update cycle applies next frame\n\nprint(damaged:GetAttribute(\"damaged\")) -- true\n</code></pre> <p>Calling <code>SetAttribute()</code> on the <code>Instance</code></p> <pre><code>part:SetAttribute(\"damaged\", false)\n\nprint(damaged:get()) -- false\n</code></pre>"},{"location":"tutorials/instances/change-events/","title":"Change events","text":"<p><code>OnChange</code> is a function that returns keys to use when hydrating or creating an instance. Those keys let you connect functions to property changed events on the instance.</p> <pre><code>local input = New \"TextBox\" {\n    [OnChange \"Text\"] = function(newText)\n        print(\"You typed:\", newText)\n    end\n}\n</code></pre>"},{"location":"tutorials/instances/change-events/#usage","title":"Usage","text":"<p>To use <code>OnChange</code> in your code, you first need to import it from the Fusion module, so that you can refer to it by name:</p> <pre><code>local Weave = require(ReplicatedStorage.Weave)\nlocal OnChange = Weave.OnChange\n</code></pre> <p>When you call <code>OnChange</code> with a property name, it will return a special key:</p> <pre><code>local key = OnEvent(\"Activated\")\n</code></pre> <p>When used in a property table, you can pass in a handler and it will be run when that property changes. The new value of the property is passed in:</p> <pre><code>local input = New \"TextBox\" {\n    [OnChange(\"Text\")] = function(newText)\n        print(\"You typed:\", newText)\n    end\n}\n</code></pre> <p>If you're using quotes <code>'' \"\"</code> for the event name, the extra parentheses <code>()</code> are optional:</p> <pre><code>local input = New \"TextBox\" {\n    [OnChange \"Text\"] = function(newText)\n        print(\"You typed:\", newText)\n    end\n}\n</code></pre> A warning about using OnChange with state objects <p>When passing a state object as a property, changes will only affect the property on the next frame:</p> <pre><code>local text = Value.new(\"Hello\")\n\nlocal message = New \"Message\" {\n    Text = text\n}\n\nprint(message.Text) --&gt; Hello\n\ntext:set(\"World\")\nprint(message.Text) --&gt; Hello\ntask.wait() -- wait for next frame\nprint(message.Text) --&gt; World\n</code></pre> <p>This means <code>OnChange</code> for that property will run your handlers one frame after the state object is changed. This could introduce off-by-one-frame errors. For this case, prefer to use an observer on the state object directly for zero latency.</p>"},{"location":"tutorials/instances/change-events/#differences-from-roblox-api","title":"Differences from Roblox API","text":"<p>Normally in the Roblox API, when using <code>:GetPropertyChangedSignal()</code> on an instance, the handler callback will not receive any arguments.</p> <p>It's worth noting that <code>OnChange</code> is not identical in that respect. To make working with change events easier, <code>OnChange</code> will pass the new value of the property to the handler callback.</p>"},{"location":"tutorials/instances/cleanup/","title":"Cleanup","text":"<p>The <code>[Cleanup]</code> key allows you to add cleanup code to an instance you're hydrating or creating. You can also pass in instances or event connections to destroy.</p> <pre><code>local connection = RunService.Heartbeat:Connect(function()\n    print(\"Blah blah...\")\nend)\n\nlocal part = New \"Part\" {\n    [Cleanup] = connection\n}\n</code></pre> <pre><code>local box = New \"SelectionBox\" {\n    Parent = PlayerGui\n}\n\nlocal part = New \"Part\" {\n    [Cleanup] = box\n}\n</code></pre> <pre><code>local part = New \"Part\" {\n    [Cleanup] = {\n        function()\n            print(\"Oh no, I got destroyed. Ouch :(\")\n        end,\n        connection,\n        box\n    }\n}\n</code></pre>"},{"location":"tutorials/instances/cleanup/#usage","title":"Usage","text":"<p>To use <code>Cleanup</code> in your code, you first need to import it from the Fusion module, so that you can refer to it by name:</p> <pre><code>local Weave = require(ReplicatedStorage.Weave)\nlocal Cleanup = Weave.Cleanup\n</code></pre> <p>When using <code>New</code> or <code>Hydrate</code>, you can use <code>[Cleanup]</code> as a key in the property table. Any function you pass in will be run when the instance is destroyed:</p> <pre><code>local folder = New \"Folder\" {\n    [Cleanup] = function()\n        print(\"This folder was destroyed\")\n    end\n}\n</code></pre> <p>Arrays are supported - their contents will be cleaned up in order:</p> <pre><code>local folder = New \"Folder\" {\n    [Cleanup] = {\n        function()\n            print(\"This will run first\")\n        end,\n        function()\n            print(\"This will run next\")\n        end,\n        function()\n            print(\"This will run last\")\n        end\n    }\n}\n</code></pre> <p>You may also nest arrays up to any depth - sub-arrays are also run in order:</p> <pre><code>local folder = New \"Folder\" {\n    [Cleanup] = {\n        function()\n            print(\"This will run first\")\n        end,\n        {\n            function()\n                print(\"This will run next\")\n            end,\n            function()\n                print(\"This will run second-to-last\")\n            end,\n        },\n        function()\n            print(\"This will run last\")\n        end\n    }\n}\n</code></pre> <p>For convenience, <code>Cleanup</code> allows you to pass some types of value in directly. Passing in an instance will destroy it:</p> <pre><code>local box = New \"SelectionBox\" {\n    Parent = PlayerGui\n}\n\nlocal part = New \"Part\" {\n    -- `box` will be destroyed when the part is destroyed\n    [Cleanup] = box\n}\n</code></pre> <p>Passing in an event connection will disconnect it:</p> <pre><code>local connection = RunService.Heartbeat:Connect(function()\n    print(\"Blah blah...\")\nend)\n\nlocal part = New \"Part\" {\n    -- `connection` will be disconnected when the part is destroyed\n    [Cleanup] = connection\n}\n</code></pre> <p>Finally, passing in anything with a <code>:destroy()</code> or <code>:Destroy()</code> method will have that method called:</p> <pre><code>-- you might receive an object like this from a third party library\nlocal object = {}\nfunction object:destroy()\n    print(\"I was destroyed!\")\nend\n\nlocal part = New \"Part\" {\n    -- `object:destroy()` will be called when the part is destroyed\n    [Cleanup] = object\n}\n</code></pre> <p>Any other kind of value will do nothing by default.</p>"},{"location":"tutorials/instances/cleanup/#dont-use-destroyed","title":"Don't Use Destroyed","text":"<p>While Roblox does provide it's own <code>Destroyed</code> event, it should not be relied upon for cleaning up correctly in all cases. It only fires when the <code>Destroy</code> method is called, meaning other kinds of destruction are ignored.</p> <p>For example, notice only one of these parts runs their cleanup code:</p> Script codeOutput <pre><code>local part1 = New \"Part\" {\n    [OnEvent \"Destroyed\"] = function()\n        print(\"=&gt; Part 1 cleaned up\")\n    end\n}\n\nlocal part2 = New \"Part\" {\n    [OnEvent \"Destroyed\"] = function()\n        print(\"=&gt; Part 2 cleaned up\")\n    end\n}\n\nprint(\"Destroying part 1...\")\npart1:Destroy()\n\nprint(\"Setting part 2 to nil...\")\npart2 = nil\n</code></pre> <pre><code>Destroying part 1...\n=&gt; Part 1 cleaned up\nSetting part 2 to nil...\n</code></pre> <p>Meanwhile, Fusion's <code>[Cleanup]</code> will work regardless of how your instances were destroyed, meaning you can avoid serious memory leaks:</p> Script codeOutput <pre><code>local part1 = New \"Part\" {\n    [Cleanup] = function()\n        print(\"=&gt; Part 1 cleaned up\")\n    end\n}\n\nlocal part2 = New \"Part\" {\n    [Cleanup] = function()\n        print(\"=&gt; Part 2 cleaned up\")\n    end\n}\n\nprint(\"Destroying part 1...\")\npart1:Destroy()\n\nprint(\"Setting part 2 to nil...\")\npart2 = nil\n</code></pre> <pre><code>Destroying part 1...\n=&gt; Part 1 cleaned up\nSetting part 2 to nil...\n=&gt; Part 2 cleaned up\n</code></pre>"},{"location":"tutorials/instances/events/","title":"Events","text":"<p><code>OnEvent</code> is a function that returns keys to use when hydrating or creating an instance. Those keys let you connect functions to events on the instance.</p> <pre><code>local button = New \"TextButton\" {\n    [OnEvent \"Activated\"] = function(_, numClicks)\n        print(\"The button was pressed\", numClicks, \"time(s)!\")\n    end\n}\n</code></pre>"},{"location":"tutorials/instances/events/#usage","title":"Usage","text":"<p>To use <code>OnEvent</code> in your code, you first need to import it from the Fusion module, so that you can refer to it by name:</p> <pre><code>local Weave = require(ReplicatedStorage.Weave)\nlocal OnEvent = Weave.OnEvent\n</code></pre> <p>When you call <code>OnEvent</code> with an event name, it will return a special key:</p> <pre><code>local key = OnEvent(\"Activated\")\n</code></pre> <p>When that key is used in a property table, you can pass in a handler and it will be connected to the event for you:</p> <pre><code>local button = New \"TextButton\" {\n    [OnEvent(\"Activated\")] = function(_, numClicks)\n        print(\"The button was pressed\", numClicks, \"time(s)!\")\n    end\n}\n</code></pre> <p>If you're using quotes <code>'' \"\"</code> for the event name, the extra parentheses <code>()</code> are optional:</p> <pre><code>local button = New \"TextButton\" {\n    [OnEvent \"Activated\"] = function(_, numClicks)\n        print(\"The button was pressed\", numClicks, \"time(s)!\")\n    end\n}\n</code></pre>"},{"location":"tutorials/instances/new-instances/","title":"New Instances","text":"<p>Fusion provides a <code>New</code> function when you're hydrating newly-made instances. It creates a new instance, applies some default properties, then hydrates it with a property table.</p> <pre><code>local message = Value.new(\"Hello there!\")\n\nlocal ui = New \"TextLabel\" {\n    Name = \"Greeting\",\n    Parent = PlayerGui.ScreenGui,\n\n    Text = message\n}\n\nprint(ui.Name) --&gt; Greeting\nprint(ui.Text) --&gt; Hello there!\n\nmessage:set(\"Goodbye friend!\")\ntask.wait() -- important: changes are applied on the next frame!\nprint(ui.Text) --&gt; Goodbye friend!\n</code></pre>"},{"location":"tutorials/instances/new-instances/#usage","title":"Usage","text":"<p>To use <code>New</code> in your code, you first need to import it from the Fusion module, so that you can refer to it by name:</p> <pre><code>local Weave = require(ReplicatedStorage.Weave)\nlocal New = Weave.New\n</code></pre> <p>The <code>New</code> function is called in two parts. First, call the function with the type of instance, then pass in the property table:</p> <pre><code>local instance = New(\"Part\")({\n    Parent = workspace,\n    Color = Color3.new(1, 0, 0)\n})\n</code></pre> <p>If you're using curly braces <code>{}</code> for your properties, and quotes <code>'' \"\"</code> for your class type, the extra parentheses <code>()</code> are optional:</p> <pre><code>-- This only works when you're using curly braces {} and quotes '' \"\"!\nlocal instance = New \"Part\" {\n    Parent = workspace,\n    Color = Color3.new(1, 0, 0)\n}\n</code></pre> <p>By design, <code>New</code> works just like <code>Hydrate</code> - it will apply properties the same way. See the Hydrate tutorial to learn more.</p>"},{"location":"tutorials/instances/new-instances/#default-properties","title":"Default Properties","text":"<p>When you create an instance using <code>Instance.new()</code>, Roblox will give it some default properties. However, these tend to be outdated and aren't useful for most people, leading to repetitive boilerplate needed to disable features that nobody wants to use.</p> <p>The <code>New</code> function will apply some of it's own default properties to fix this. For example, by default borders on UI are disabled, automatic colouring is turned off and default content is removed.</p> <p> </p> <p>For a complete list, take a look at Fusion's default properties file.</p>"},{"location":"tutorials/instances/outputs/","title":"Outputs","text":"<p><code>Out</code> is a function that returns keys to use when hydrating or creating an instance. Those keys let you output a property's value to a <code>Value</code> object.</p> <pre><code>local name = Value.new()\n\nlocal thing = New \"Part\" {\n    [Out \"Name\"] = name\n}\n\nprint(name:get()) --&gt; Part\n\nthing.Name = \"Jimmy\"\nprint(name:get()) --&gt; Jimmy\n</code></pre>"},{"location":"tutorials/instances/outputs/#usage","title":"Usage","text":"<p>To use <code>Out</code> in your code, you first need to import it from the Fusion module, so that you can refer to it by name:</p> <pre><code>local Weave = require(ReplicatedStorage.Weave)\nlocal Out = Weave.Out\n</code></pre> <p>When you call <code>Out</code> with a property name, it will return a special key:</p> <pre><code>local key = Out(\"Activated\")\n</code></pre> <p>When used in a property table, you can pass in a <code>Value</code> object. It will be set to the value of the property, and when the property changes, it will be set to the new value:</p> <pre><code>local name = Value.new()\n\nlocal thing = New \"Part\" {\n    [Out(\"Name\")] = name\n}\n\nprint(name:get()) --&gt; Part\n\nthing.Name = \"Jimmy\"\nprint(name:get()) --&gt; Jimmy\n</code></pre> <p>If you're using quotes <code>'' \"\"</code> for the event name, the extra parentheses <code>()</code> are optional:</p> <pre><code>local thing = New \"Part\" {\n    [Out \"Name\"] = name\n}\n</code></pre>"},{"location":"tutorials/instances/outputs/#two-way-binding","title":"Two-Way Binding","text":"<p>By default, <code>Out</code> only outputs changes to the property. If you set the value to something else, the property remains the same:</p> <pre><code>local name = Value.new()\n\nlocal thing = New \"Part\" {\n    [Out \"Name\"] = name -- When `thing.Name` changes, set `name`\n}\n\nprint(thing.Name, name:get()) --&gt; Part Part\nname:set(\"NewName\")\ntask.wait()\nprint(thing.Name, name:get()) --&gt; Part NewName\n</code></pre> <p>If you want the value to both change and be changed by the property, you need to explicitly say so:</p> <pre><code>local name = Value.new()\n\nlocal thing = New \"Part\" {\n    Name = name -- When `name` changes, set `thing.Name`\n    [Out \"Name\"] = name -- When `thing.Name` changes, set `name`\n}\n\nprint(thing.Name, name:get()) --&gt; Part Part\nname:set(\"NewName\")\ntask.wait()\nprint(thing.Name, name:get()) --&gt; NewName NewName\n</code></pre> <p>This is known as two-way binding. Most of the time you won't need it, but it can come in handy when working with some kinds of UI - for example, a text box that users can write into, but which can also be modified by your scripts.</p>"},{"location":"tutorials/instances/parenting/","title":"Children","text":"<p>The <code>[Children]</code> key allows you to add children when hydrating or creating an instance.</p> <p>It accepts instances, arrays of children and state objects containing children.</p> <pre><code>local Children = Weave.Children\nlocal folder = New \"Folder\" {\n    [Children] = {\n        New \"Part\" {\n            Name = \"Gregory\",\n            Color = Color3.new(1, 0, 0)\n        },\n        New \"Part\" {\n            Name = \"Sammy\",\n            Material = \"Glass\"\n        }\n    }\n}\n</code></pre>"},{"location":"tutorials/instances/parenting/#usage","title":"Usage","text":"<p>To use <code>Children</code> in your code, you first need to import it from the Fusion module, so that you can refer to it by name:</p> <pre><code>local Weave = require(ReplicatedStorage.Weave)\nlocal Children = Weave.Children\n</code></pre> <p>When using <code>New</code> or <code>Hydrate</code>, you can use <code>[Children]</code> as a key in the property table. Any instance you pass in will be parented:</p> <pre><code>local folder = New \"Folder\" {\n    -- The part will be moved inside of the folder\n    [Children] = workspace.Part\n}\n</code></pre> <p>Since <code>New</code> and <code>Hydrate</code> both return their instances, you can nest them:</p> <pre><code>-- Makes a Folder, containing a part called Gregory\nlocal folder = New \"Folder\" {\n    [Children] = New \"Part\" {\n        Name = \"Gregory\",\n        Color = Color3.new(1, 0, 0)\n    }\n}\n</code></pre> <p>If you need to parent multiple children, arrays of children are accepted:</p> <pre><code>-- Makes a Folder, containing parts called Gregory and Sammy\nlocal folder = New \"Folder\" {\n    [Children] = {\n        New \"Part\" {\n            Name = \"Gregory\",\n            Color = Color3.new(1, 0, 0)\n        },\n        New \"Part\" {\n            Name = \"Sammy\",\n            Material = \"Glass\"\n        }\n    }\n}\n</code></pre> <p>Arrays can be nested to any depth; all children will still be parented:</p> <pre><code>local folder = New \"Folder\" {\n    [Children] = {\n        {\n            {\n                {\n                    New \"Part\" {\n                        Name = \"Gregory\",\n                        Color = Color3.new(1, 0, 0)\n                    }\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>Similarly, state objects containing children (or <code>nil</code>) are also allowed:</p> <pre><code>local value = Value.new()\n\nlocal folder = New \"Folder\" {\n    [Children] = value\n}\n\nvalue:set(\n    New \"Part\" {\n        Name = \"Clyde\",\n        Transparency = 0.5\n    }\n)\n</code></pre> <p>You may use any combination of these to parent whichever children you need:</p> <pre><code>local modelChildren = workspace.Model:GetChildren()\nlocal includeModel = Value.new(true)\n\nlocal folder = New \"Folder\" {\n    -- array of children\n    [Children] = {\n        -- single instance\n        New \"Part\" {\n            Name = \"Gregory\",\n            Color = Color3.new(1, 0, 0)\n        },\n        -- state object containing children (or nil)\n        Computed(function()\n            return if includeModel:get()\n                then modelChildren:GetChildren() -- array of children\n                else nil\n        end)\n    }\n}\n</code></pre>"},{"location":"tutorials/instances/references/","title":"References","text":"<p>The <code>[Ref]</code> key allows you to save a reference to an instance you're hydrating or creating.</p> <pre><code>local myRef = Value.new()\n\nlocal thing = New \"Part\" {\n    [Ref] = myRef\n}\n\nprint(myRef:get()) --&gt; Part\nprint(myRef:get() == thing) --&gt; true\n</code></pre>"},{"location":"tutorials/instances/references/#usage","title":"Usage","text":"<p>To use <code>Ref</code> in your code, you first need to import it from the Fusion module, so that you can refer to it by name:</p> <pre><code>local Weave = require(ReplicatedStorage.Weave)\nlocal Ref = Weave.Ref\n</code></pre> <p>When using <code>New</code> or <code>Hydrate</code>, you can use <code>[Ref]</code> as a key in the property table. It expects a value object to be passed in, and it will save a reference to the instance in that object:</p> <pre><code>local myRef = Value.new()\n\nNew \"Part\" {\n    [Ref] = myRef\n}\n\nprint(myRef:get()) --&gt; Part\n</code></pre> <p>When the instance is cleaned up, the value object is set to nil to avoid memory leaks:</p> <pre><code>local myPart = Value.new()\n\nNew \"Part\" {\n    [Ref] = myPart\n}\n\nprint(myPart:get()) --&gt; Part\n\nmyPart:get():Destroy()\n\nprint(myPart:get()) --&gt; nil\n</code></pre>"},{"location":"tutorials/instances/references/#when-to-use-this","title":"When To Use This","text":"<p>You may have noticed that <code>New</code> and <code>Hydrate</code> already return their instances. You might wonder why there's two ways to get the same instance reference:</p> <pre><code>local fromRef = Value.new()\nlocal returned = New \"Part\" {\n    [Ref] = fromRef\n}\n\nprint(returned) --&gt; Part\nprint(fromRef:get()) --&gt; Part\n\nprint(returned == fromRef:get()) --&gt; true\n</code></pre> <p>There are two main use cases. Firstly, when you're using <code>[Children]</code> to nest instances inside each other, it's hard to access the instance reference:</p> <pre><code>local folders = New \"Folder\" {\n    [Children] = New \"Folder\" {\n        -- the instance reference gets passed straight into [Children]\n        -- so... how do you save this somewhere else?\n        [Children] = New \"Part\" {}\n    }\n}\n</code></pre> <p>One solution is to extract the <code>New</code> call out to a separate variable. This is the simplest solution, but because the part is separated from the folders, it's harder to see they're related at a glance:</p> <pre><code>-- build the part elsewhere, so it can be saved to a variable\nlocal myPart = New \"Part\" {}\n\nlocal folders = New \"Folder\" {\n    [Children] = New \"Folder\" {\n        -- use the saved reference\n        [Children] = myPart\n    }\n}\n</code></pre> <p><code>Ref</code> allows you to save the reference without moving the <code>New</code> call:</p> <pre><code>-- use a Value instead of a plain variable, so it can be passed to `Ref`\nlocal myPart = Value.new()\n\nlocal folders = New \"Folder\" {\n    [Children] = New \"Folder\" {\n        [Children] = New \"Part\" {\n            -- save a reference into the value object\n            [Ref] = myPart\n        }\n    }\n}\n</code></pre> <p>The second use case arises when one instance needs to refer to another. Since <code>Ref</code> saves to a value object, you can pass the object directly into another <code>New</code> or <code>Hydrate</code> call:</p> <pre><code>local myPart = Value.new()\n\nNew \"SelectionBox\" {\n    -- the selection box should adorn to the part\n    Adornee = myPart\n}\n\nNew \"Part\" {\n    -- saving a reference to `myPart`, which will change the Adornee prop above\n    [Ref] = myPart\n}\n</code></pre> <p>These aren't the only use cases for <code>Ref</code>, but they're the most common patterns which are worth covering.</p>"},{"location":"tutorials/lists-and-tables/forkeys/","title":"ForKeys","text":"<p><code>ForKeys</code> is a state object that creates a new table by processing keys from another table.</p> <p>The input table can be a state object, and the output keys can use state objects.</p> <pre><code>local data = {Red = \"foo\", Blue = \"bar\"}\nlocal prefix = Value.new(\"Key_\")\n\nlocal renamed = ForKeys(data, function(key)\n    return prefix:get() .. key\nend)\n\nprint(renamed:get()) --&gt; {Key_Red = \"foo\", Key_Blue = \"bar\"}\n\nprefix:set(\"colour\")\nprint(renamed:get()) --&gt; {colourRed = \"foo\", colourBlue = \"bar\"}\n</code></pre>"},{"location":"tutorials/lists-and-tables/forkeys/#usage","title":"Usage","text":"<p>To use <code>ForKeys</code> in your code, you first need to import it from the Fusion module, so that you can refer to it by name:</p> <pre><code>local Weave = require(ReplicatedStorage.Weave)\nlocal ForKeys = Weave.ForKeys\n</code></pre>"},{"location":"tutorials/lists-and-tables/forkeys/#basic-usage","title":"Basic Usage","text":"<p>To create a new <code>ForKeys</code> object, call the constructor with an input table and a processor function:</p> <pre><code>local data = {red = \"foo\", blue = \"bar\"}\nlocal renamed = ForKeys(data, function(key)\n    return string.upper(key)\nend)\n</code></pre> <p>This will generate a new table, where each key is replaced using the processor function. You can get the table using the <code>:get()</code> method:</p> <pre><code>local data = {red = \"foo\", blue = \"bar\"}\nlocal renamed = ForKeys(data, function(key)\n    return string.upper(key)\nend)\n\nprint(renamed:get()) --&gt; {RED = \"foo\", BLUE = \"bar\"}\n</code></pre>"},{"location":"tutorials/lists-and-tables/forkeys/#state-objects","title":"State Objects","text":"<p>The input table can be provided as a state object instead, and the output table will update as the input table is changed:</p> <pre><code>local playerSet = Value.new({})\nlocal userIdSet = ForKeys(playerSet, function(player)\n    return player.UserId\nend)\n\nplayerSet:set({ [Players.Elttob] = true })\nprint(userIdSet:get()) --&gt; {[1670764] = true}\n\nplayerSet:set({ [Players.boatbomber] = true, [Players.EgoMoose] = true })\nprint(userIdSet:get()) --&gt; {[33655127] = true, [2155311] = true}\n</code></pre> <p>Additionally, you can use state objects in your calculations, just like a computed:</p> <pre><code>local playerSet = { [Players.boatbomber] = true, [Players.EgoMoose] = true }\nlocal prefix = Value.new(\"User_\")\nlocal userIdSet = ForKeys(playerSet, function(player)\n    return prefix .. player.UserId\nend)\n\nprint(userIdSet:get()) --&gt; {User_33655127 = true, User_2155311 = true}\n\nprefix:set(\"player\")\nprint(userIdSet:get()) --&gt; {player33655127 = true, player2155311 = true}\n</code></pre>"},{"location":"tutorials/lists-and-tables/forkeys/#cleanup-behaviour","title":"Cleanup Behaviour","text":"<p>Similar to computeds, if you want to run your own code when values are removed, you can pass in a second 'destructor' function:</p> <pre><code>local eventSet = Value.new({\n    [RunService.RenderStepped] = true,\n    [RunService.Heartbeat] = true\n})\n\nlocal connectionSet = ForKeys(eventSet,\n    -- processor\n    function(event)\n        local eventName = tostring(event)\n        local connection = event:Connect(function(...)\n            print(eventName, \"fired with arguments:\", ...)\n        end)\n        return connection\n    end,\n    -- destructor\n    function(connection)\n        print(\"Disconnecting the event!\")\n        connection:Disconnect() -- don't forget we're overriding the default cleanup\n    end\n)\n\n-- remove Heartbeat from the event set\n-- this will run the destructor with the Heartbeat connection\neventSet:set({ [RunService.RenderStepped] = true }) --&gt; Disconnecting the event!\n</code></pre> <p>When using a custom destructor, you can send one extra return value to your destructor without including it in the output table:</p> <pre><code>local eventSet = Value.new({\n    [RunService.RenderStepped] = true,\n    [RunService.Heartbeat] = true\n})\n\nlocal connectionSet = ForKeys(eventSet,\n    -- processor\n    function(event)\n        local eventName = tostring(event)\n        local connection = event:Connect(function(...)\n            print(eventName, \"fired with arguments:\", ...)\n        end)\n        return connection, eventName\n    end,\n    -- destructor\n    function(connection, eventName)\n        print(\"Disconnecting \" .. eventName .. \"!\")\n        connection:Disconnect()\n    end\n)\n\neventSet:set({ [RunService.RenderStepped] = true }) --&gt; Disconnecting Signal Heartbeat!\n</code></pre>"},{"location":"tutorials/lists-and-tables/forkeys/#optimisations","title":"Optimisations","text":"<p>Optional</p> <p>You don't have to memorise these optimisations to use <code>ForKeys</code>, but it can be helpful if you have a performance problem.</p> <p>Rather than creating a new output table from scratch every time the input table is changed, <code>ForKeys</code> will try and reuse as much as possible to improve performance.</p> <p>For example, let's say we're converting an array to a dictionary:</p> <pre><code>local array = Value.new({\"Fusion\", \"Knit\", \"Matter\"})\nlocal dict = ForKeys(array, function(index)\n    return \"Value\" .. index\nend)\n\nprint(dict:get()) --&gt; {Value1 = \"Fusion\", Value2 = \"Knit\", Value3 = \"Matter\"}\n</code></pre> <p>Because <code>ForKeys</code> only operates on the keys, changing the values in the array doesn't affect the keys. Keys are only added or removed as needed:</p> <pre><code>local array = Value.new({\"Fusion\", \"Knit\", \"Matter\"})\nlocal dict = ForKeys(array, function(index)\n    return \"Value\" .. index\nend)\n\nprint(dict:get()) --&gt; {Value1 = \"Fusion\", Value2 = \"Knit\", Value3 = \"Matter\"}\n\narray:set({\"Roact\", \"Rodux\"})\nprint(dict:get()) --&gt; {Value1 = \"Roact\", Value2 = \"Rodux\"}\n</code></pre> <p><code>ForKeys</code> takes advantage of this - when a value changes, it's copied into the output table without recalculating the key. Keys are only calculated when a value is assigned to a new key.</p>"},{"location":"tutorials/lists-and-tables/forpairs/","title":"ForPairs","text":"<p><code>ForPairs</code> combines the functions of <code>ForValues</code> and <code>ForKeys</code> into one object. It can process pairs of keys and values at the same time.</p> <p>The input table can be a state object, and the output values can use state objects.</p> <pre><code>local itemColours = { shoes = \"red\", socks = \"blue\" }\nlocal owner = Value.new(\"Elttob\")\n\nlocal manipulated = ForPairs(itemColours, function(thing, colour)\n    local newKey = colour\n    local newValue = owner:get() .. \"'s \" .. thing\n    return newKey, newValue\nend)\n\nprint(manipulated:get()) --&gt; {red = \"Elttob's shoes\", blue = \"Elttob's socks\"}\n\nowner:set(\"Quenty\")\nprint(manipulated:get()) --&gt; {red = \"Quenty's shoes\", blue = \"Quenty's socks\"}\n</code></pre>"},{"location":"tutorials/lists-and-tables/forpairs/#usage","title":"Usage","text":"<p>To use <code>ForPairs</code> in your code, you first need to import it from the Fusion module, so that you can refer to it by name:</p> <pre><code>local Weave = require(ReplicatedStorage.Weave)\nlocal ForPairs = Weave.ForPairs\n</code></pre>"},{"location":"tutorials/lists-and-tables/forpairs/#basic-usage","title":"Basic Usage","text":"<p>To create a new <code>ForPairs</code> object, call the constructor with an input table and a processor function:</p> <pre><code>local itemColours = { shoes = \"red\", socks = \"blue\" }\nlocal swapped = ForPairs(data, function(key, value)\n    return value, key\nend)\n</code></pre> <p>This will generate a new table, where each key-value pair is replaced using the processor function. You can get the table using the <code>:get()</code> method:</p> <pre><code>local itemColours = { shoes = \"red\", socks = \"blue\" }\nlocal swapped = ForPairs(data, function(key, value)\n    return value, key\nend)\n\nprint(swapped:get()) --&gt; {red = \"shoes\", blue = \"socks\"}\n</code></pre>"},{"location":"tutorials/lists-and-tables/forpairs/#state-objects","title":"State Objects","text":"<p>As with <code>ForKeys</code> and <code>ForValues</code>, the input table can be provided as a state object, and the processor function can use other state objects in its calculations. See the ForValues page for examples.</p>"},{"location":"tutorials/lists-and-tables/forpairs/#cleanup-behaviour","title":"Cleanup Behaviour","text":"<p>Similar to <code>ForValues</code> and <code>ForKeys</code>, you may pass in a 'destructor' function to add cleanup behaviour, and send your own metadata to it:</p> <pre><code>local watchedInstances = Value.new({\n    [workspace.Part1] = \"One\",\n    [workspace.Part2] = \"Two\",\n    [workspace.Part3] = \"Three\"\n})\n\nlocal connectionSet = ForPairs(eventSet,\n    -- processor\n    function(instance, displayName)\n        local metadata = { displayName = displayName, numChanges = 0 }\n        local connection = instance.Changed:Connect(function()\n            print(\"Instance\", displayName, \"was changed!\")\n            metadata.numChanges += 1\n        end)\n        return instance, connection, metadata\n    end,\n    -- destructor\n    function(instance, connection, metadata)\n        print(\"Removing\", metadata.displayName, \"after\", metadata.numChanges, \"changes\")\n        connection:Disconnect() -- don't forget we're overriding the default cleanup\n    end\n)\n\n-- remove Part3 from the input table\n-- this will run the destructor with Part3, its Changed event, and its metadata\nwatchedInstances:set({\n    [workspace.Part1] = \"One\",\n    [workspace.Part2] = \"Two\"\n})\n</code></pre>"},{"location":"tutorials/lists-and-tables/forpairs/#optimisations","title":"Optimisations","text":"<p>Optional</p> <p>You don't have to memorise these optimisations to use <code>ForPairs</code>, but it can be helpful if you have a performance problem.</p> <p>Rather than creating a new output table from scratch every time the input table is changed, <code>ForPairs</code> will try and reuse as much as possible to improve performance.</p> <p>Since <code>ForPairs</code> has to depend on both keys and values, changing any value in the input table will cause a recalculation for that key-value pair.</p> <p> </p> <p>Inversely, <code>ForPairs</code> won't recalculate any key-value pairs that stay the same. Instead, these will be preserved in the output table.</p> <p> </p> <p>If you don't need the keys or the values, Fusion can offer better optimisations. For example, if you're working with an array of values where position doesn't matter, ForValues can move values between keys.</p> <p>Alternatively, if you're working with a set of objects stored in keys, and don't need the values in the table, ForKeys will ignore the values for optimal performance.</p>"},{"location":"tutorials/lists-and-tables/forvalues/","title":"ForValues","text":"<p><code>ForValues</code> is a state object that creates a new table by processing values from another table.</p> <p>The input table can be a state object, and the output values can use state objects.</p> <pre><code>local numbers = {1, 2, 3, 4, 5}\nlocal multiplier = Value.new(2)\n\nlocal multiplied = ForValues(numbers, function(num)\n    return num * multiplier:get()\nend)\n\nprint(multiplied:get()) --&gt; {2, 4, 6, 8, 10}\n\nmultiplier:set(10)\nprint(multiplied:get()) --&gt; {10, 20, 30, 40, 50}\n</code></pre>"},{"location":"tutorials/lists-and-tables/forvalues/#usage","title":"Usage","text":"<p>To use <code>ForValues</code> in your code, you first need to import it from the Fusion module, so that you can refer to it by name:</p> <pre><code>local Weave = require(ReplicatedStorage.Weave)\nlocal ForValues = Weave.ForValues\n</code></pre>"},{"location":"tutorials/lists-and-tables/forvalues/#basic-usage","title":"Basic Usage","text":"<p>To create a new <code>ForValues</code> object, call the constructor with an input table and a processor function:</p> <pre><code>local numbers = {1, 2, 3, 4, 5}\nlocal doubled = ForValues(numbers, function(num)\n    return num * 2\nend)\n</code></pre> <p>This will generate a new table of values, where each value is passed through the processor function. You can get the table using the <code>:get()</code> method:</p> <pre><code>local numbers = {1, 2, 3, 4, 5}\nlocal doubled = ForValues(numbers, function(num)\n    return num * 2\nend)\n\nprint(doubled:get()) --&gt; {2, 4, 6, 8, 10}\n</code></pre>"},{"location":"tutorials/lists-and-tables/forvalues/#state-objects","title":"State Objects","text":"<p>The input table can be provided as a state object instead, and the output table will update as the input table is changed:</p> <pre><code>local numbers = Value.new({})\nlocal doubled = ForValues(numbers, function(num)\n    return num * 2\nend)\n\nnumbers:set({1, 2, 3, 4, 5})\nprint(doubled:get()) --&gt; {2, 4, 6, 8, 10}\n\nnumbers:set({5, 15, 25})\nprint(doubled:get()) --&gt; {10, 30, 50}\n</code></pre> <p>Additionally, you can use state objects in your calculations, just like a computed:</p> <pre><code>local numbers = {1, 2, 3, 4, 5}\nlocal factor = Value.new(2)\nlocal multiplied = ForValues(numbers, function(num)\n    return num * factor:get()\nend)\n\nprint(multiplied:get()) --&gt; {2, 4, 6, 8, 10}\n\nfactor:set(10)\nprint(multiplied:get()) --&gt; {10, 20, 30, 40, 50}\n</code></pre>"},{"location":"tutorials/lists-and-tables/forvalues/#cleanup-behaviour","title":"Cleanup Behaviour","text":"<p>Similar to computeds, if you want to run your own code when values are removed, you can pass in a second 'destructor' function:</p> <pre><code>local names = Value.new({\"Jodi\", \"Amber\", \"Umair\"})\nlocal textLabels = ForValues(names,\n    -- processor\n    function(name)\n        return New \"TextLabel\" {\n            Text = name\n        }\n    end,\n    -- destructor\n    function(textLabel)\n        print(\"Destructor got text label:\", textLabel.Text)\n        textLabel:Destroy() -- don't forget we're overriding the default cleanup\n    end\n)\n\n-- remove Jodi from the names list\n-- this will run the destructor with Jodi's TextLabel\nnames:set({\"Amber\", \"Umair\"}) --&gt; Destructor got text label: Jodi\n</code></pre> <p>When using a custom destructor, you can send one extra return value to your destructor without including it in the output table:</p> <pre><code>local names = Value.new({\"Jodi\", \"Amber\", \"Umair\"})\nlocal textLabels = ForValues(names,\n    -- processor\n    function(name)\n        local textLabel = New \"TextLabel\" {\n            Text = name\n        }\n        local uppercased = name:upper()\n        -- `textLabel` will be included in the output table\n        -- `uppercased` is not included, but still passed to the destructor\n        return textLabel, uppercased\n    end,\n    -- destructor\n    function(textLabel, uppercased)\n        print(\"Destructor got uppercased:\", uppercased)\n        textLabel:Destroy()\n    end\n)\n\nnames:set({\"Amber\", \"Umair\"}) --&gt; Destructor got uppercased: JODI\n</code></pre>"},{"location":"tutorials/lists-and-tables/forvalues/#optimisations","title":"Optimisations","text":"<p>Optional</p> <p>You don't have to memorise these optimisations to use <code>ForValues</code>, but it can be helpful if you have a performance problem.</p> <p>Rather than creating a new output table from scratch every time the input table is changed, <code>ForValues</code> will try and reuse as much as possible to improve performance.</p> <p>For example, let's say we're measuring the lengths of an array of words:</p> <pre><code>local words = Value.new({\"Orange\", \"Red\", \"Magenta\"})\nlocal lengths = ForValues(words, function(word)\n    return #word\nend)\n\nprint(lengths:get()) --&gt; {6, 3, 7}\n</code></pre> <p>The word lengths don't depend on the position of the word in the array. This means that rearranging the words in the input array will just rearrange the lengths in the output array:</p> <p> </p> <p><code>ForValues</code> takes advantage of this - when input values move around, the output values will move around too, instead of being recalculated.</p> <p>Note that values are only reused once. For example, if you added another occurence of 'Orange', your calculation would have to run again for the second 'Orange':</p> <p> </p>"},{"location":"tutorials/lists-and-tables/the-for-objects/","title":"The For Objects","text":"<p>Often when building UI, you need to deal with lists, arrays and tables. For example:</p> <ul> <li>creating an array of TextLabels for a player list</li> <li>generating a settings page from pairs of keys and values in a configuration</li> <li>filling a grid with inventory slots and items</li> </ul> <p>Most of these use cases involve processing one table into another:</p> <ul> <li>converting an array of player names into an array of TextLabels</li> <li>converting a table of settings into a table of UI controls</li> <li>converting an array of inventory items into an array of slot UIs</li> </ul> <p>So, to assist with these use cases, Fusion has a few state objects which are specially designed for working with arrays and tables. These are known as the <code>For</code> objects.</p>"},{"location":"tutorials/lists-and-tables/the-for-objects/#the-problem","title":"The Problem","text":"<p>To start, let's try making a player list using the basic state objects from before. Let's define a changeable list of player names and some basic UI:</p> <pre><code>local playerNames = Value.new({\"Elttob\", \"boatbomber\", \"thisfall\", \"AxisAngles\"})\n\nlocal textLabels = {} -- TODO: implement this\n\nlocal ui = New \"ScreenGui\" {\n    Parent = Players.LocalPlayer.PlayerGui,\n\n    [Children] = New \"Frame\" {\n        Name = \"PlayerList\",\n\n        Position = UDim2.fromScale(1, 1),\n        AnchorPoint = Vector2.new(1, 0),\n        Size = UDim2.fromOffset(200, 0),\n        AutomaticSize = \"Y\",\n\n        [Children] = {\n            New \"UIListLayout\" {\n                SortOrder = \"Name\"\n            },\n            textLabels\n        }\n    }\n}\n</code></pre> <p>Now, let's make a <code>Computed</code> which generates that list of text labels for us:</p> <pre><code>local playerNames = Value.new({\"Elttob\", \"boatbomber\", \"thisfall\", \"AxisAngles\"})\n\nlocal textLabels = Computed(function()\n    local out = {}\n    for index, playerName in playerNames:get() do\n        out[index] = New \"TextLabel\" {\n            Name = playerName,\n            Size = UDim2.new(1, 0, 0, 50),\n            Text = playerName\n        }\n    end\n    return out\nend, Fusion.cleanup)\n\nlocal ui = New \"ScreenGui\" {\n    Parent = Players.LocalPlayer.PlayerGui,\n</code></pre> <p>This is alright, but there are a few problems:</p> <ul> <li>Firstly, there's a fair amount of boilerplate - in order to generate the list   of text labels, you have to create a <code>Computed</code>, initialise a new table, write a   for-loop to populate the table, then return it. - Boilerplate is generally annoying, and especially so for a task as common   as dealing with lists and tables. It's less clear to read and more tedious   to write.</li> <li>Secondly, whenever <code>playerNames</code> is changed, you reconstruct the entire list,   destroying all of your instances and any data associated with them. This is both   inefficient and also causes issues with data loss. - Ideally, you should only modify the text labels for players that have   joined or left, leaving the rest of the text labels alone.</li> </ul> <p>To address this shortcoming, the <code>For</code> objects provide a cleaner way to do the same thing, except with less boilerplate and leaving unchanged values alone:</p> <pre><code>local playerNames = Value.new({\"Elttob\", \"boatbomber\", \"thisfall\", \"AxisAngles\"})\n\nlocal textLabels = ForValues(playerNames, function()\n    return New \"TextLabel\" {\n        Name = playerName,\n        Size = UDim2.new(1, 0, 0, 50),\n        Text = playerName\n    }\nend, Fusion.cleanup)\n\nlocal ui = New \"ScreenGui\" {\n    Parent = Players.LocalPlayer.PlayerGui,\n</code></pre> <p>Over the next few pages, we'll take a look at three state objects:</p> <ul> <li><code>ForValues</code>, which lets you process just the values in a table.</li> <li><code>ForKeys</code>, which lets you process just the keys in a table.</li> <li><code>ForPairs</code>, which lets you do both at the same time.</li> </ul>"},{"location":"tutorials/networking/networkvalue/","title":"NetworkValue","text":"<p>A Weave <code>NetworkValue</code> stores a value and updates to ALL clients.</p> <p><code>:get()</code> and <code>:set()</code> its value from the Server.</p> <p>ONLY <code>:get()</code> on the Client.</p>"},{"location":"tutorials/networking/networkvalue/#server","title":"Server","text":"<pre><code>local blueScore = NetworkValue.new(\"BlueScore\", 0)\n\nblueScore:get() --&gt; 0\nblueScore:set(1)\nblueScore:get() --&gt; 1\n</code></pre>"},{"location":"tutorials/networking/networkvalue/#client","title":"Client","text":"<pre><code>local blueScore = NetworkValue.new(\"BlueScore\")\nblueScore:get() --&gt; 1\n\nblueScore:set(0) --&gt; ERROR - Cannot set NetworkValue from the Client.\n</code></pre>"},{"location":"tutorials/networking/networkvalue/#recommended-usage","title":"Recommended Usage","text":"<p>Create a <code>NetworkValue</code> in <code>ReplicatedStorage</code>, so you can access it on <code>Server</code> and <code>Client</code>.</p>"},{"location":"tutorials/networking/networkvalue/#replicatedstorage","title":"ReplicatedStorage","text":"<pre><code>local Weave = require(ReplicatedStorage.Weave)\nlocal NetworkValue = Weave.NetworkValue\n\nreturn NetworkValue.new(\"RedScore\", 0)\n</code></pre>"},{"location":"tutorials/networking/networkvalue/#server_1","title":"Server","text":"<p>On the Server, this returns a <code>NetworkValue</code> object that you can <code>:set()</code>.</p> <pre><code>local RedScore = require(ReplicatedStorage.NetworkValues.RedScore)\n\nRedScore:set(1)\n</code></pre>"},{"location":"tutorials/networking/networkvalue/#client_1","title":"Client","text":"<p>On the Client this returns a Weave <code>Value</code> object.</p> <pre><code>local RedScore = require(ReplicatedStorage.NetworkValues.RedScore)\n\nRedScore:get() --&gt; 1\n</code></pre>"},{"location":"tutorials/networking/playervalue/","title":"PlayerValue","text":"<p>A Weave <code>PlayerValue</code> stores a value and updates for a specific player.</p> <p><code>:getFor(player)</code> and <code>:setFor(player, newValue)</code> from the Server.</p> <p>ONLY <code>:get()</code> on the Client.</p> <p>From the client can read from them with <code>:get()</code>.</p>"},{"location":"tutorials/networking/playervalue/#server","title":"Server","text":"<pre><code>local playerCash = PlayerValue.new(\"PlayerCash\", 0)\n\nPlayers.PlayerAdded:Connect(function(player: Player)\n    playerCash:getFor(player1)   --&gt; 0\n    playerCash:setFor(player1, 1)\n    playerCash:getFor(player1)   --&gt; 1\nend)\n</code></pre>"},{"location":"tutorials/networking/playervalue/#client","title":"Client","text":"<pre><code>local playerCash = PlayerValue.new(\"PlayerCash\")\nplayerCash:get()     --&gt; 0\n</code></pre>"},{"location":"tutorials/networking/playervalue/#recommended-usage","title":"Recommended Usage","text":"<p>The recommended way to use <code>PlayerValue</code> is to create a module script in ReplicatedStorage that exports a <code>PlayerValue</code> object. This way you can require the <code>PlayerValue</code> object from any script on the client or server. On the client this would return a Weave <code>Value</code> object, on the server it would return a <code>PlayerValue</code> object that can update all clients Weave <code>Value</code> objects.</p>"},{"location":"tutorials/networking/playervalue/#replicatedstorage","title":"ReplicatedStorage","text":"<pre><code>local Weave = require(ReplicatedStorage.Weave)\nlocal PlayerValue = Weave.PlayerValue\nlocal playerCash = PlayerValue.new(\"PlayerCash\", 0)\n</code></pre>"},{"location":"tutorials/networking/playervalue/#server_1","title":"Server","text":"<pre><code>local playerCash = require(ReplicatedStorage.PlayerValues.PlayerCash)\n\nPlayers.PlayerAdded:Connect(function(player: Player)\n    playerCash:getFor(player1)   --&gt; 0\n    playerCash:setFor(player1, 1)\n    playerCash:getFor(player1)   --&gt; 1\nend)\n</code></pre>"},{"location":"tutorials/networking/playervalue/#client_1","title":"Client","text":"<pre><code>local playerCash = require(ReplicatedStorage.PlayerValues.PlayerCash)\nplayerCash:get()        --&gt; 1\n</code></pre>"},{"location":"tutorials/networking/profileplayervalue/","title":"ProfilePlayerValue","text":"<p>A Weave <code>PlayerProfileValue</code>:</p> <ul> <li>Stores the value for a specific player</li> <li>Updates the player's value in <code>ProfileService</code></li> <li>Broadcasts updates to one player</li> </ul> <p><code>:getFor(player)</code> and <code>:setFor(player, newValue)</code> from the Server.</p> <p>ONLY <code>:get()</code> on the Client.</p>"},{"location":"tutorials/networking/profileplayervalue/#profileservice","title":"ProfileService","text":"<pre><code>return {\n    Gems = 0,\n}\n</code></pre>"},{"location":"tutorials/networking/profileplayervalue/#server","title":"Server","text":"<pre><code>local playerGems = PlayerProfileValue.new(\"PlayerGems\", \"Gems\")\n\nPlayers.PlayerAdded:Connect(function(player: Player)\n    PlayerLevels:getFor(player)         --&gt; 1\n    PlayerLevels:setFor(player, 2)\n    PlayerLevels:getFor(player)         --&gt; 2\nend)\n</code></pre>"},{"location":"tutorials/networking/profileplayervalue/#client","title":"Client","text":"<pre><code>local playerGems = PlayerProfileValue.new(\"PlayerGems\", \"Gems\")\nlocal localPlayer = Players.LocalPlayer\n\nplayerGems:get()                --&gt; 100\n</code></pre> <p>When the player leaves the experience their value is automatically cleared from the <code>PlayerProfileValue</code> object.</p> <p>When the player joins the experience their value is automatically loaded from the ProfileService into the <code>PlayerProfileValue</code> object.</p>"},{"location":"tutorials/networking/profileplayervalue/#recommended-usage","title":"Recommended Usage","text":"<p>The recommended way to use <code>PlayerProfileValue</code> is to create a module script in ReplicatedStorage that exports a <code>PlayerProfileValue</code> object. This way you can require the <code>PlayerProfileValue</code> object from any script on the client or server. On the client this would return a Weave <code>Value</code> object, on the server it would return a <code>PlayerProfileValue</code> object that can update all clients Weave <code>Value</code> objects.</p>"},{"location":"tutorials/networking/profileplayervalue/#replicatedstorage","title":"ReplicatedStorage","text":"<pre><code>local Weave = require(ReplicatedStorage.Weave)\nlocal PlayerProfileValue = Weave.PlayerProfileValue\n\nreturn PlayerProfileValue.new(\"PlayerGems\", \"Gems\")\n</code></pre>"},{"location":"tutorials/networking/profileplayervalue/#server_1","title":"Server","text":"<pre><code>local PlayerLevels = require(ReplicatedStorage.PlayerProfileValues.PlayerLevels)\n\nPlayers.PlayerAdded:Connect(function(player: Player)\n    PlayerLevels:getFor(player)         --&gt; 1\n    PlayerLevels:setFor(player, 2)\n    PlayerLevels:getFor(player)         --&gt; 2\nend)\n</code></pre>"},{"location":"tutorials/networking/profileplayervalue/#client_1","title":"Client","text":"<pre><code>local PlayerLevels = require(ReplicatedStorage.PlayerProfileValues.PlayerLevels)\nPlayerLevels:get()                  --&gt; 2\n</code></pre>"},{"location":"tutorials/networking/profilevalue/","title":"ProfileValue","text":"<p>A Weave <code>ProfileValue</code>: - Stores the value for a specific player - Updates the player's value in <code>ProfileService</code> - Broadcasts updates to a ALL players</p> <p><code>:getFor(player)</code> and <code>:setFor(player, newValue)</code> from the Server.</p> <p>ONLY <code>:get()</code> on the Client.</p>"},{"location":"tutorials/networking/profilevalue/#profileservice","title":"ProfileService","text":"<pre><code>return {\n    Level = 1,\n}\n</code></pre>"},{"location":"tutorials/networking/profilevalue/#server","title":"Server","text":"<pre><code>local playerLevels = ProfileValue.new(\"PlayerLevels\", \"Level\")\nlocal player = Players:GetPlayers()[1]\n\nplayerLevels:getFor(player)         --&gt; 1\nplayerLevels:setFor(player, 2)\nplayerLevels:getFor(player)         --&gt; 2\n</code></pre>"},{"location":"tutorials/networking/profilevalue/#client","title":"Client","text":"<pre><code>local playerLevels = ProfileValue.new(\"PlayerLevels\", \"Level\")\nlocal localPlayer = Players.LocalPlayer\n\nplayerLevels:get()                  --&gt; { [localPlayer] = 2 }\nplayerLevels:get()[localPlayer]     --&gt; 2\n</code></pre> <p>When the player leaves the experience their value is automatically cleared from the <code>ProfileValue</code> object.</p> <p>When the player joins the experience their value is automatically loaded from the ProfileService into the <code>ProfileValue</code> object.</p>"},{"location":"tutorials/networking/profilevalue/#recommended-usage","title":"Recommended Usage","text":"<p>The recommended way to use <code>ProfileValue</code> is to create a module script in ReplicatedStorage that exports a <code>ProfileValue</code> object. This way you can require the <code>ProfileValue</code> object from any script on the client or server. On the client this would return a Weave <code>Value</code> object, on the server it would return a <code>ProfileValue</code> object that can update all clients Weave <code>Value</code> objects.</p>"},{"location":"tutorials/networking/profilevalue/#replicatedstorage","title":"ReplicatedStorage","text":"<pre><code>local Weave = require(ReplicatedStorage.Weave)\nlocal ProfileValue = Weave.ProfileValue\nreturn ProfileValue.new(\"PlayerLevels\", \"Level\")\n</code></pre>"},{"location":"tutorials/networking/profilevalue/#server_1","title":"Server","text":"<pre><code>local PlayerLevels = require(ReplicatedStorage.ProfileValues.PlayerLevels)\nlocal player = Players:GetPlayers()[1]\n\nPlayerLevels:getFor(player)     --&gt; 1\nPlayerLevels:setFor(player, 2)\nPlayerLevels:getFor(player)     --&gt; 2\n</code></pre>"},{"location":"tutorials/networking/profilevalue/#client_1","title":"Client","text":"<pre><code>local PlayerLevels = require(ReplicatedStorage.ProfileValues.PlayerLevels)\nlocal localPlayer = Players.LocalPlayer\n\nPlayerLevels:get()                  --&gt; { [localPlayer] = 2 }\nPlayerLevels:get()[localPlayer]     --&gt; 2\n</code></pre>"}]}